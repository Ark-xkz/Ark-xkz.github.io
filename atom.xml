<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xkz的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.arkxkz.com/"/>
  <updated>2020-06-16T03:32:08.594Z</updated>
  <id>https://www.arkxkz.com/</id>
  
  <author>
    <name>Ark-xkz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件加密的概念和运用</title>
    <link href="https://www.arkxkz.com/2020/06/16/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E8%BF%90%E7%94%A8/"/>
    <id>https://www.arkxkz.com/2020/06/16/文件加密的概念和运用/</id>
    <published>2020-06-16T02:55:58.000Z</published>
    <updated>2020-06-16T03:32:08.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>讲解文件加密解密的基础概念</p><p>使用gpg4win进行加密和解密</p><p>讲解数字签名和数字证书的基本概念</p></blockquote><a id="more"></a><p>参考文献：阮一峰的数字签名和数字证书讲解：<a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></p><h2 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h2><ol><li>对称式加密：加密和解密都用的同一个密钥，我们日常最熟悉的账号登录有点类似这种加密方式。</li><li>非对称式加密：加密和解密用的不同的密钥。往最简单的说用于加密的密钥叫做公钥，解密的叫做私钥（这样说不合理，因为私钥也可以用于加密，如数字签名等，但是这里为了初步了解概念，可以暂时这样理解，之后看了数字签名后就会有更合理的理解）</li></ol><h2 id="公钥和私钥的理解"><a href="#公钥和私钥的理解" class="headerlink" title="公钥和私钥的理解"></a>公钥和私钥的理解</h2><p>​        针对于我们的日常文件安全，如果网上传递的信息不进行加密，而进行明文传输，很容易被他人截取并加以利用，特别是在我们的隐私方面。</p><p>​        我们将公钥和私钥看成锁和钥匙。公钥为锁，私钥是钥匙。我们生成密钥之后，私钥（私钥）由我们本人保管好，不能给他人。锁（公钥）可以发送给任何需要传递文件给我的人。这些要发送文件给我的人，用我给的锁将信息锁住（加密），经由各种方式这个带锁的文件传递到我手里，我使用自己的钥匙（私钥）将对应的锁打开，得到真正内容。中途落到其它人手里，因为没有锁，无法打开得到真正信息。</p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>软件：gpg4win</p><h3 id="软件安装（windows）"><a href="#软件安装（windows）" class="headerlink" title="软件安装（windows）"></a>软件安装（windows）</h3><ul><li>下载地址：<a href="https://gpg4win.org/download.html" target="_blank" rel="noopener">https://gpg4win.org/download.html</a></li><li>全部默认配置</li><li>最终在桌面上得到Kleopatra软件</li></ul><h3 id="生成自己的公钥和私钥"><a href="#生成自己的公钥和私钥" class="headerlink" title="生成自己的公钥和私钥"></a>生成自己的公钥和私钥</h3><ol><li>新建新建密钥对：点击文件中国的新建密钥对</li><li>输入自己的名字和邮箱</li><li><img src="https://ae01.alicdn.com/kf/H3578ddc09dcd4437a43bcd0d5033cc70L.jpg" alt></li><li>输入一个自己的安全密码：一定要记住</li><li><img src="https://ae01.alicdn.com/kf/H5c496246f569498ca3dcccb80f4007abJ.jpg" alt></li><li>最终得到一对密钥，选择生成副本：其实就是导出私钥</li><li><img src="https://ae01.alicdn.com/kf/H046020c538a94dd3b5b606cd3e16d1ce2.jpg" alt></li><li>查看私钥</li><li><img src="https://ae01.alicdn.com/kf/H67bd0b81d5c74a16b7e978890534e319G.jpg" alt></li><li>在软件里选择导出：就是导出公钥</li><li><img src="https://ae01.alicdn.com/kf/H6c43f76fc981405fb2d0963246c1584e4.jpg" alt></li><li>查看公钥</li><li><img src="https://ae01.alicdn.com/kf/H748a4a3c5f2b45529d210ec7a2e2e1daW.jpg" alt></li></ol><h3 id="进行文件加密和解密"><a href="#进行文件加密和解密" class="headerlink" title="进行文件加密和解密"></a>进行文件加密和解密</h3><ul><li>点击软件的加密，选择一个文件加密。</li><li><img src="https://ae01.alicdn.com/kf/Hb990affdd6724af1a8def50b4794276fR.jpg" alt></li><li>选择为自己加密，输入创建密钥时候的密码。</li><li><img src="https://ae01.alicdn.com/kf/H1f5adbea4e14411090b901b380543872A.jpg" alt></li><li>输出一个文件，这个文件在其它电脑上（不知道私钥的情况下）是打不开的。</li><li>在本机直接打开显示乱码，软件记录了你的私钥，因此可以用软件打开，选择解密。</li></ul><h3 id="文件加密传输和解密"><a href="#文件加密传输和解密" class="headerlink" title="文件加密传输和解密"></a>文件加密传输和解密</h3><ul><li>背景：A同学想要B同学加密文件后传输给他</li><li>过程：——类似自己加密解密<ul><li>A同学生成一对密钥，导出文件（公钥）后，将文件发给B同学。</li><li>B同学使用gpgwin4软件，导入A同学发的公钥后，使用加密。将加密后的文件随便用什么方式发给A</li><li>A拿到文件后，用自己的私钥进行解密。最终得到可阅读文件。</li></ul></li></ul><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><ul><li>背景：A将自己的公钥发送给B后，双方进行通信交流。非对称加密解密技术保证了B发送信息给A的安全性。但是如何确保回复信息的内容在中途被随意改变部分？</li><li>过程：<ul><li>A在收到B的来信解密后，自己写了一段回复信息</li><li>A对回复内容Hash提炼出文章摘要</li><li>对于这个摘要，A使用自己的“私钥”进行加密，生成“数字签名”，</li><li>A将这个签名贴在自己原本加密的回复信息后，一起发送给B</li><li>B收到这个信息后，用自己的私钥解密主要文本内容，用A的公钥解密数字签名得到摘要。</li><li>B用同样的Hash方法处理信息的内容，得到的摘要与从数字签名解密出的摘要相对比。</li><li>如果内容一致，说明信息是A发送且没有被改写</li></ul></li></ul><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><ul><li>背景：数字签名解决了回复信息中途被改写的风险，但是也存在极端情况，就是C趁着B不注意，将B手里A的公钥替换成C的公钥，这样一来B发送的消息全部只能被C解读并且C可以满足数字签名的要求回复信息给B。所以我们要解决的是如何确保交流双方的身份正常。</li><li>解决思路：<ul><li>找一个很有权威的中间人，A去这个中间人做CA（证书中心），为A自己的公钥做认证，将A的公钥发布在CA中。这个中间人用自己的私钥给A的公钥和其它相关信息一起加密，生成一个数字证书，这个证书没人都是唯一的。</li><li>A每次发送消息给B的时候，只需要将CA发布的自己的数字证书一起贴在内容后发送给B</li><li>B在收到信息后，用CA提供的公钥，就能解开数字证书得到公钥，将得到的公钥与自己手里A的公钥做出对比，一致的话说明发送人是A</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;讲解文件加密解密的基础概念&lt;/p&gt;
&lt;p&gt;使用gpg4win进行加密和解密&lt;/p&gt;
&lt;p&gt;讲解数字签名和数字证书的基本概念&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://www.arkxkz.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="文件加密" scheme="https://www.arkxkz.com/tags/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/"/>
    
      <category term="gpg4win" scheme="https://www.arkxkz.com/tags/gpg4win/"/>
    
  </entry>
  
  <entry>
    <title>Git的使用教程</title>
    <link href="https://www.arkxkz.com/2020/06/13/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://www.arkxkz.com/2020/06/13/Git的使用教程/</id>
    <published>2020-06-13T15:06:27.000Z</published>
    <updated>2020-06-13T15:10:37.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>git 的使用教程，详细版</p></blockquote><a id="more"></a><h1 id="Git的使用教程"><a href="#Git的使用教程" class="headerlink" title="Git的使用教程"></a>Git的使用教程</h1><blockquote><p>参考文献：<a href="https://zhuanlan.zhihu.com/p/135183491" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/135183491</a></p></blockquote><h2 id="Git的基本概念"><a href="#Git的基本概念" class="headerlink" title="Git的基本概念"></a>Git的基本概念</h2><ul><li>定义：分布式版本控制系统</li><li>组成：<ul><li>remote（远程仓库）：例如github或者gitee等，属于网络资源</li><li>workspace（工作区）：就是项目代码等实际操作区间</li><li>index（缓存）：作为一种保护机制，缓存内容</li><li>reposity（本地仓库）：本地上正式提交给远程的地方</li></ul></li><li>基本框架图：<img src="https://ae01.alicdn.com/kf/H682ef4394bb94e9d915d184254f0078ae.jpg" alt></li></ul><ul><li>git的优点<ul><li><strong>分布式</strong>：git的分布式是指没有中央服务器，每个参与开发人员都有一个完整的库，自己工作的时候不需要联网进行协调，只需要在将最终的稳定版提交到远程，供伙伴使用。</li><li>与分布式管理对应的是SVN（集中版本控制系统），SVN所有模块的协调都是统一从一个中央仓库中进行，进行相互调整必须统一到中央仓库中，导致对中央仓库带宽要求高，并且相互协作不方便。</li></ul></li></ul><hr><h2 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h2><p>使用git管理项目</p><h3 id="创建本地仓库（reposity）"><a href="#创建本地仓库（reposity）" class="headerlink" title="创建本地仓库（reposity）"></a>创建本地仓库（reposity）</h3><ul><li>本质：就是建立一个本地存储空间，这个空间被git这个工具管理，所有的操作能够被追踪。</li><li>过程：<ul><li>在windows下右键，点击git bash(仅仅是为了好用)</li><li>创建一个目录，进入这个目录后，初始化仓库（git init）<img src="https://ae01.alicdn.com/kf/H6a52a450808e4ae1a891e64f4660b0a1u.jpg" alt></li><li>这个ShowGit就是这次项目的工作区间，其中 .git/ 就是git的管理空间。</li><li>自己在目录下创建文件，添加文件到暂存区（index）<img src="https://ae01.alicdn.com/kf/Hb2a687f284e44096819a07ab1188b1dbs.jpg" alt></li><li>将文件提交到本地仓库（reposity），最好每次提交都加上说明<img src="https://ae01.alicdn.com/kf/He83470bb40284ba48d15adc223c621c45.jpg" alt></li><li>没有提示则表明成功，可以用git status 来查看状态</li><li>自己修改已经提交后的文件，再次查看状态，发现有提示<img src="https://ae01.alicdn.com/kf/H493c7afc17144ddea71d539f24db89d04.jpg" alt></li><li>使用命令git diff XX_file 来追踪文本内容改变。<img src="https://ae01.alicdn.com/kf/Ha67e8bfb12424e16bb174746ea08aa3cL.jpg" alt></li><li>查看放心后，再次添加到index并commit<img src="https://ae01.alicdn.com/kf/H589441b21aa04b619168c816a109a6c5O.jpg" alt></li></ul></li><li>使用命令总结：<ul><li>git init：将此空间初始化为本地仓库</li><li>git add XX_file 将某文件添加到index区</li><li>git commit -m “说明”：将整个版本提交到本地仓库</li><li>git status：查看目前的状态</li><li>git diff XX_file：显示文本内容的差别之处</li></ul></li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul><li>概念：将已经提交给reposity的版本回退到之前版本</li><li>步骤：<ul><li>继续在文件后面添加一行“3333”，并提交<img src="https://ae01.alicdn.com/kf/Hc15cf9a0be2740869c6cbdf851dc82c4N.jpg" alt></li><li>查看git的提交记录<img src="https://ae01.alicdn.com/kf/H8376b413ec2e4fc9a50de86c74e46535q.jpg" alt></li><li>回退到上一次提交的版本，1、“git reset –hard HEAD^”，回退到上上次版本就是两个”^”，多次之前使用”~n”<img src="https://ae01.alicdn.com/kf/H8c8f27da05e84209904ca7b0a851d033X.jpg" alt></li><li>回退完想要恢复到回退之间的版本<img src="https://ae01.alicdn.com/kf/He9d65f6bb8ab4759afe6f2e599d2e74cT.jpg" alt></li></ul></li><li>使用命令总结<ul><li>git log [–pretty=oneline] ：查看提交日志信息，加上–pretty=oneline表示简化显示</li><li>git reset –hard XXX：回退版本，XXX 表示一个版本</li><li>git reflog：查看各个版本的标记号</li></ul></li></ul><h3 id="git的撤销和修改"><a href="#git的撤销和修改" class="headerlink" title="git的撤销和修改"></a>git的撤销和修改</h3><ul><li>区别：与版本撤回不一样，撤销是指发生在workspace和index之间的操作</li><li>方法：使用 checkout – XXX_file</li><li>步骤：<ul><li>用git status查看状态</li><li>用git checkout –file 丢弃上一次在工作区间未提交的所有修改<img src="https://ae01.alicdn.com/kf/Hc67263ab755348078ff929d9657476deC.jpg" alt></li></ul></li><li>命令总结<ul><li>git checkout – filename：撤回</li></ul></li></ul><h3 id="git的删除和恢复"><a href="#git的删除和恢复" class="headerlink" title="git的删除和恢复"></a>git的删除和恢复</h3><ul><li>删除：<ul><li>直接rm file</li><li>然后git rm file 和添加到index和 commit提交<img src="https://ae01.alicdn.com/kf/H2eab2860fcb646c88456fbf827f75830V.jpg" alt></li></ul></li><li>恢复<ul><li>在commit之间使其修改<img src="https://pics.images.ac.cn/image/5ee4dbc2cf480.html" alt></li></ul></li></ul><h3 id="部署远程仓库（remote）"><a href="#部署远程仓库（remote）" class="headerlink" title="部署远程仓库（remote）"></a>部署远程仓库（remote）</h3><p>将remote的项目与本地reposity之间建立联系</p><ul><li>添加到远程仓库<ul><li>概念：同时在本地和远程建立一个库，为这个两个库建立同步</li><li>在github上新建立个库<img src="https://ae01.alicdn.com/kf/Hc780a358ee514d12bb62d01555fe4609m.jpg" alt></li><li>看到官方文档说明命令2，与本地仓库关联</li><li>将本地推送到远程<img src="https://ae01.alicdn.com/kf/Ha6e25dfe8d0848a69d35c80a41932650K.jpg" alt></li><li>刷新网页后可以查看内容<img src="https://ae01.alicdn.com/kf/Hf741ca1e21ef4a2b849a27d26ba1718at.jpg" alt></li><li>在最开始push时候与master建立连接，之后直接push就行。</li><li>说明：<ul><li>第一次推送，remote是空的，加-u表示保证git将本地master分支与远程master分支关联。之后直接写推送默认推送到master分支上。</li></ul></li></ul></li><li>从远程克隆到本地<ul><li>在某一文件夹内遇见打开git bash</li><li>输入对应的github项目网址<img src="https://ae01.alicdn.com/kf/H52e746f252c54fe5b2df87117de50ba8I.jpg" alt></li></ul></li><li>分支的创建与合并<ul><li>原因：以上使用的都是主分支master，一般我们是不会对master进行反复修改的，必须保证master的稳定。</li><li>分支的创建<ul><li>创建方法：在当前分支下，使用命令 git checkout -b 分支名<img src="https://ae01.alicdn.com/kf/H3702645c24d24ae8bdcf0521d5717333s.jpg" alt></li><li>说明<ul><li>git checkout -b XX 是两个命令的缩写<ul><li>git branch XX：创建XX分支</li><li>git switch XX：转移到XX分支</li></ul></li><li>git branch：查看所以分支和当前分支</li></ul></li></ul></li><li>分支的合并<ul><li>方法：在提交之后，需要将2个分支合并到同一分支。使用git merge XX</li><li>切换到分支fenzhi_1后，在readme后添加一行文字，提交。<img src="https://ae01.alicdn.com/kf/H1288c6cb808c422d898602604e7e71f2H.jpg" alt></li><li>切换到master后看不到添加内容<img src="https://ae01.alicdn.com/kf/He8cf09ece80142f89d00e88cd8f2ecd77.jpg" alt></li><li>合并后可以看到<img src="https://ae01.alicdn.com/kf/H11077ccd0c7d4bf9819b95c3d55a1bdbB.jpg" alt></li></ul></li><li>分支删除<ul><li>命令：git branch -d XX分支</li><li>用git brach 查看分支<img src="https://ae01.alicdn.com/kf/Hba07cf3546b94c7ea896729357c97a35T.jpg" alt></li></ul></li><li>分支管理<ul><li>一般默认是“Fast forward”模式，再这样的模式下进行分支删除会将全部分支信息删除掉。</li><li>分支策略<ul><li>一般是不允许直接在master汇总干活的，在master上的的必须是非常稳定的版本，一般进行开发是在新建的分支dev上进行，最终调试完整后就合并到主分支上</li></ul></li><li>方法<ul><li>在创建的dev分支下的test文件添加一行字，在主分支无法看见<img src="https://ae01.alicdn.com/kf/H3d84bfd8345c44e581e7d1c0644db63dH.jpg" alt></li><li>在合并时候使用“–no-ff”的参数来禁止“Fast forward”<img src="https://ae01.alicdn.com/kf/He68187d1ff9b49b7a8699d2f780e56acL.jpg" alt></li><li>删除分支<img src="https://ae01.alicdn.com/kf/H96879d83011f47a3980c13c44c6005cef.jpg" alt></li><li>用git log查看信息<img src="https://ae01.alicdn.com/kf/H668dbcc926a0497aab397f18fb6726b9y.jpg" alt></li></ul></li></ul></li><li>Bug分支<ul><li>运用场景：在某一个分支的修改中，突然遇到了另一个更加紧急的bug，需要先完成紧急任务。</li><li>过程：<ul><li>创建一个dev分支，对test文件修改<img src="https://ae01.alicdn.com/kf/H974c69bd18ba48549fe39a048d989e02F.jpg" alt></li><li>未提交的时候后，遇到readme文件里面更加紧急bug，用git stash隐藏当前工作区<img src="https://ae01.alicdn.com/kf/H75647fe5e9624cb990fdbe764ec4dfca2.jpg" alt></li><li>跳转到待更改的master分支，创建另外一个分支，并对readme修改<img src="https://ae01.alicdn.com/kf/H9ce03a3752544d77bcfd1d740d95b67fd.jpg" alt></li><li>跳回到master，并删除分支</li><li>跳转到dev1，继续任务，先查看被隐藏的工作区<img src="https://ae01.alicdn.com/kf/Haeb4810210354a41a3748dc1b296bf15H.jpg" alt></li><li>两种方法恢复：1、使用git stash pop，在恢复一条操作时候，同时删除stash里面的记录。2、使用git stash apply和git stash drop 分别完成恢复和删除任务<img src="https://ae01.alicdn.com/kf/Hf164606b1bcc4b95a630d5856c68f5866.jpg" alt></li><li>最终提交，回到master合并，删除<img src="https://ae01.alicdn.com/kf/Hd690ef738da04190bba9c98de75a17b8e.jpg" alt></li></ul></li></ul></li></ul></li></ul><hr><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>同时多个人协同开发项目时候，会存在多个分支的交互情况</p><ul><li>remote库的名称查看<ul><li>git remote：查看基本信息</li><li>git remote -v：查看较为详细信息</li></ul></li><li>分支推送——push<ul><li>命令：git push [-u] remote_name branch_name</li><li>参数解读：<ul><li>-u：第一次push，与master建立联系</li><li>remote_name：remote库的名称，用git remote 查看，一般github上是origin</li><li>branch_name：推送到的分支名称，主分支就是master</li></ul></li><li>实例：<ul><li><img src="https://ae01.alicdn.com/kf/H079a2be6aa4e47efbce5f748aaafd88cQ.jpg" alt></li></ul></li></ul></li><li>分支抓取<ul><li>背景：多人协作开发，想要在别人推送的分支上更改</li><li>过程：<ul><li>伙伴也从remote里clone了项目<img src="https://ae01.alicdn.com/kf/H3f053ee83c4141a9b1c40b6c7d5a7dc6N.jpg" alt></li><li>伙伴需要再分支上开发，在本地创建分支时候要指定分支来源<img src="https://ae01.alicdn.com/kf/Hcee1c40ab87c4e288c67d911f4961749C.jpg" alt></li><li>伙伴做出修改后push到远程dev分支<img src="https://ae01.alicdn.com/kf/Hb6b9b34c0a2b43b888ff63a8bc933c9fZ.jpg" alt></li><li>我此时直接pull会有问题，要根据提示与远程的dev分支建立联系<img src="https://ae01.alicdn.com/kf/Habc32d2cbd5841a4ae80e9f9558421ccr.jpg" alt></li><li>自己在本地就能查看到伙伴更改的部分。<img src="https://ae01.alicdn.com/kf/H7d919aedd1e547ce8d89fd3562ded6ccC.jpg" alt></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;git 的使用教程，详细版&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="git" scheme="https://www.arkxkz.com/categories/git/"/>
    
    
      <category term="git" scheme="https://www.arkxkz.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://www.arkxkz.com/2020/03/08/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://www.arkxkz.com/2020/03/08/红黑树/</id>
    <published>2020-03-08T11:10:12.000Z</published>
    <updated>2020-03-08T11:15:08.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>红黑树的概念</li><li>红黑树的插入和删除</li></ul></blockquote><a id="more"></a><hr><blockquote><p>红黑树（Red Black Tree）</p><p>参照大神：<a href="https://zhuanlan.zhihu.com/p/57041683" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57041683</a></p></blockquote><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>前提：</p><ul><li>自平衡的二叉查找树</li><li>符合查找树的一些特征</li></ul><p>附加：</p><ul><li>节点是红色或者黑色</li><li>根节点是黑色</li><li>叶子结点是黑色（空节点NIL）</li><li>每个红色节点的左右节点都是黑色(路径上不能有连续的红节点)</li><li>每个节点到每个叶子结点包含的黑色节点都相同</li></ul><p><strong>特点：</strong></p><ul><li>从根到叶子结点最长路径不会超过最短路径的2倍</li></ul><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>关键在于插入后如何进行调整</p><p>假设我们插入节点是X（插入节点一定是红色节点），它的父节点是P，P的父节点是PP，PP的右孩子是Pb，Pb的左右节点分别是pbl与pbr。假设PP是黑色</p><p>可能出现的情况：（都拿插入节点在左子树上为例子）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 最简单的情况：P为黑色       不变          结束</span><br><span class="line">2. P为红色：</span><br><span class="line">1）pb是红色     P变黑，PP红，pb黑     PP可能会引起连锁反应</span><br><span class="line">    2）pb黑色，X，P,PP在直线P黑，PP红，PP右旋   结束</span><br><span class="line">    3）pb黑色，X，P，PP不在一条直线P左旋，重置X，P转化为2）</span><br></pre></td></tr></table></figure><p>示例：</p><p>将按照{6,3,5,2,4,1,0}的顺序插入：</p><p><img src="https://ae01.alicdn.com/kf/Hf00d47e8255847c6b2ace6b1b5ef758fG.png" alt></p><p><img src="https://ae01.alicdn.com/kf/H026af9e7f4654eb89a340326570d2f23O.png" alt></p><p><img src="https://ae01.alicdn.com/kf/H6527ba61b187433baa0d5e8a3ce11e1fs.png" alt></p><p><img src="https://ae01.alicdn.com/kf/Hee67f13304b54ab6b24f5abb6cc04254B.png" alt></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><blockquote><p>设被删除的结点为x，x的左孩子为xl(left)，右孩子为xr(right)，x的后继为s(successor)，后继的右孩子为sr，替代者为r(replacement)，被替代的颜色为rc(replacedColor)，x的父结点为p，x的兄弟节点为b，b的左右孩子分别为bl, br。</p></blockquote><h3 id="确定替换者和颜色"><a href="#确定替换者和颜色" class="headerlink" title="确定替换者和颜色"></a>确定替换者和颜色</h3><ol><li>如果xl或xr不存在时，直接把xr或xl替换x即可，故r为xr或xl，rc为x.color；否则转2。</li><li>如果<code>xr == s</code>，则只发生一次替换：s -&gt; x，故r为s，rc为x.color。</li><li>如果<code>xr != s</code>，则发生两次替换：sr -&gt; s, s -&gt; x。我们保留x位置的颜色不变，将x的颜色赋值给s，则在颜色上的替换只有一次：sr -&gt; s，我们只需要调整一个结点的黑色结点问题，此时r为s.right，rc为s.color。</li></ol><h3 id="调整替换者"><a href="#调整替换者" class="headerlink" title="调整替换者"></a>调整替换者</h3><p>总原则：</p><ul><li>x不能再变化，因为x的变化会导致左边黑色进一步减少</li><li>总需要做出点变化，不然静止不动，肯定无法解决问题</li></ul><p><img src="https://ae01.alicdn.com/kf/Hb27c0b0a4b1646dc865f6f5acbec2626n.png" alt></p><p>示例：</p><p>从插入之后，按照{6, 4, 5, 0, 1, 3, 2}顺序删除</p><p><img src="https://ae01.alicdn.com/kf/H74656573c9854d5a8ee6e34b117b11abK.png" alt></p><p><img src="https://ae01.alicdn.com/kf/H8e1f5903e0c745f098eaaac15baf3b2e9.png" alt></p><p><img src="https://ae01.alicdn.com/kf/H961fc569c1584e64bbfe6bbc544c976db.png" alt></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;红黑树的概念&lt;/li&gt;
&lt;li&gt;红黑树的插入和删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://www.arkxkz.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://www.arkxkz.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>传输层</title>
    <link href="https://www.arkxkz.com/2020/02/16/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://www.arkxkz.com/2020/02/16/传输层/</id>
    <published>2020-02-16T09:44:33.000Z</published>
    <updated>2020-02-16T09:50:48.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>传输层概念</p><p>功能</p><p>UDP和TCP</p></blockquote><a id="more"></a><hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>网络层只负责主机与主机之间的通信，但是对于用户来说，具体提供服务的是应用进程之间的通信，因此传输层提供应用进程之间的通信服务，又称为<strong>端到端的服务</strong></p><p>由于网络层是不可靠（无连接IP协议），所以可靠传输任务交给传输层，因此传输层是可靠传输，需要负责数据的查重，差错检验等。</p><p><strong>注：</strong></p><ul><li>传输层是可靠传输是因为它使用可靠传输的协议（TCP），但是传输层任然有不可靠传输协议（UDP）</li><li>端口号：1<del>1023（保留端口），1024</del>49151（登记端口），49152~65535（短暂端口）</li></ul><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><ol><li>不同应用之间的逻辑通信</li><li>进行差错检验</li><li>提供无连接或者面向连接服务</li><li>复用和分用</li><li>面向连接的提供的功能：<ol><li>连接（“握手”）</li><li>流量控制和拥塞控制</li></ol></li></ol><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><img src="https://ae01.alicdn.com/kf/Hd7c2dc8b61f647a29b43732de3704f88p.png" alt="img"></p><h3 id="UDP的构成"><a href="#UDP的构成" class="headerlink" title="UDP的构成"></a>UDP的构成</h3><ol><li>UDP首部——8B<ol><li>源端口号——2B</li><li>目的端口号——2B</li><li>长度——2B（但是一办不超过512B）</li><li>校验和——2B</li></ol></li><li>UDP数据部</li></ol><h3 id="UDP的校验"><a href="#UDP的校验" class="headerlink" title="UDP的校验"></a>UDP的校验</h3><p>伪首部：12B</p><p>内容：</p><ul><li>IP源地址地段</li><li>IP目的地址字段</li><li>全零字段</li><li>协议字段——默认为17</li><li>UDP长度字段</li></ul><p><strong>注意：</strong></p><p>伪首部只用于计算和验证校验和，不向下或者向上传递</p><p><strong>校验过程：</strong></p><p>发送方：</p><ol><li>保证UDP数据报长度为偶数字节，如果不是，添加一个0（不发送，只用于校验）</li><li>将UDP首部的校验和字段置零</li><li>将有伪首部和UDP数据报看成多个16位（2B）字，串起来</li><li>进行二进制的反码求和，结果填入校验和字段中发送出去</li></ol><p>接收方：</p><ol><li>将接收到的UDP报文添加伪首部和可能的0填充</li><li>进行相同的16位反码求和，如果结果是全一，则未出差错，否则丢弃</li></ol><p><strong>注意：</strong></p><p>反码求和：如果最高位产生进位，则需要进行“回卷”，最后取反码</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP的构成"><a href="#TCP的构成" class="headerlink" title="TCP的构成"></a>TCP的构成</h3><p><img src="https://ae01.alicdn.com/kf/Hb4eac955e6db4881b09a69d35d049487V.png" alt="img"></p><ul><li>源端口，目的端口：2B，端口号</li><li>序号：4B，TCP是面向字节流（在传输过程中是按照每一个字节来传送的），因此需要编号，确保顺序一致</li><li>确认号：4B，下次希望收到的序号（确认号-序号（收到）=这次收到TCP数据报的长度）</li><li>数据偏移：4b，不是表示数据部分的长度，而是指TCP首部的长度，和IP地址一样，以4B为单位，因此最大长度是15*4B=60B</li><li>保留：6b，目前全0</li><li>关键比特：<ul><li>URG：配合紧急指针，将该TCP数据报不经过缓冲，直接发送</li><li>ACK：确认比特，建立连接之后置1</li><li>PSH：推送比特，直接将缓冲区的数据发送</li><li>RST：复位比特，出现很大差错，释放连接，再重新建立连接</li><li>SYN：同步比特，表明这是一个连接请求或者连接接收报文</li><li>FIN：终止比特，表明已经发送完毕，释放连接</li></ul></li><li>窗口：2B，表明发送端，还可以接收该大小的数据量</li><li>校验和：2B，和UDP校验和一样</li><li>紧急指针：2B，紧急字段的最后一个字节的编号</li><li>填充字段：确保首部是4B的整数倍</li></ul><h3 id="TCP的传输："><a href="#TCP的传输：" class="headerlink" title="TCP的传输："></a>TCP的传输：</h3><ol><li>连接建立</li><li>数据传输</li><li>取消连接</li></ol><p><strong>注意：</strong></p><p>TCP传输的两端不是端口，不是IP地址，不是应用进程（只是为应用进程服务），而是<strong>套接字</strong>。因为TCP传输需要端口号和IP号，端口号确认服务与某个进程，IP号是需要将其报文交付给IP层，所以必须要知道交付主机的IP</p><h4 id="连接的建立：——三次握手"><a href="#连接的建立：——三次握手" class="headerlink" title="连接的建立：——三次握手"></a>连接的建立：——三次握手</h4><ol><li>连接请求<ol><li>客户A发送连接请求给服务器B：SYN=1，选择序号seq=x，不能带数据</li></ol></li><li>连接允许<ol><li>服务器B受到A发送的TCP数据报，回复确认：SYN=1，自己序号seq = y，确认号ack = x + 1，确认比特ACK=1，同样不能带数据。</li></ol></li><li>连接建立<ol><li>客户A受到B发送的连接允许数据报，发送确认给B，ACK=1，确认号=y+1。</li><li>B受到A发送的确认连接后，告诉应用层连接已建立</li></ol></li></ol><h4 id="连接的断开"><a href="#连接的断开" class="headerlink" title="连接的断开"></a>连接的断开</h4><ol><li>A断开连接请求：<ol><li>A向B发送：FIN=1，seq = x</li></ol></li><li>断开单通道回复：<ol><li>B向A回复：ACK = 1，seq = y，ack = x + 1</li><li>（此时只是断开a到b的通道，B还是可以传输数据给A，A也要接收）</li></ol></li><li>B断开连接请求<ol><li>B向A：FIN = 1，ACK = 1，seq =z，ack = x + 1</li></ol></li><li>断开连接确认：<ol><li>A向B回复：ACK = 1，seq = x + 1，ack = z+1</li><li>（之后要等待2MSL，确保A发送的最后一个报文到达B，因为如果没到达，B会重复发送断开连接请求。如果不等待2MSL会导致A已经断开，不会接收重传信息，B不能正常关闭）</li></ol></li></ol><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li><p>连接为什么要进行“三次握手”，而不是两次？</p><p>两次握手可能会带来连接未建立和“死锁”。两次握手导致B不需要等到接收到A的确认报文才确定连接，B在第一次收到建立连接报文后，发送一个应答报文并确认已经建立连接，可以开始向A发送数据。但是B的应答报文可能会发生丢失等情况，导致A未收到该报文，因此A认为未建立连接，那么B发送的分组都会被A丢失。同时，B发出分组超时后，会重复发送相同报文，导致“死锁”。</p></li></ol><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p><img src="https://ae01.alicdn.com/kf/H790dc93c7b114f89afd9abccc133f1abi.png" alt="img"></p><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>接收端窗口rwnd：接收端根据自己缓存大小设置的接收端容量</p><p>拥塞窗口cnnd：发送端自己估计网络的拥塞程度，反应网络当前容量。</p><p>发送端窗口上限 = Min（rwnd，cwnd）</p><p>拥塞控制的四种方法：</p><ol><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ol><p><strong>假定：</strong></p><ol><li>单向传播</li><li>以MSS（最大TCP报文）为单位，而不是以字节为单位</li><li>接收方窗口很大</li></ol><h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><ol><li><p>算法原理：</p><p>开始通信时候，并不知道当时网络负载情况，不能直接得到一个合适的拥塞窗口。因此需要进行“探测”，让拥塞窗口主键增大。</p><p>现将cwnd设置为一个单位，发送出去，在接收到确认后，将cwnd设置为当前cwnd的两倍。当cwnd到达自己设置的ssthresh后，就最后使用慢增长或者拥塞避免算法。当cwnd大于ssthresh，就不能使用慢增长算法了。</p><p>慢开始的慢并不是指cwnd增长速度慢（实际上，是按照指数增长，很快）</p></li><li><p>缺陷</p><p>探测出合适的cwnd需要消耗时间</p><p>不能人为确定合适的ssthresh</p></li></ol><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p><img src="https://ae01.alicdn.com/kf/H9f2552821a91432d8c7eb715859004d3a.png" alt="img"></p><ol><li><p>算法原理：</p><p>在到达ssthresh之后，cwnd不在是指数型增长了，而是按照每个周期1个单位的速度增长，直到发生超时重传（判断为发生阻塞）。</p><p>发生超时重传的时候，将cwnd设置为1，并将ssthresh设置为当前（超时）cwnd的一半。</p><p>阻塞避免并不是指的完全避免拥塞的发生，而是指在该阶段的增长速度为线性增长，使得发生拥塞的可能性变小。</p></li><li><p>缺点：</p><p>发生响应超时可能并不是发生了拥塞，还可能是丢失等原因。一旦发生超时，将cwnd设置为1，大大降低了传输的效率</p></li></ol><h4 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h4><p><img src="https://ae01.alicdn.com/kf/H8a92442ab8774859803073338e5352e0Q.png" alt="img"></p><ol><li><p>算法原理：</p><p>所谓快重传，就是在发生超时时候，让发送方尽快重传，而不是等待重传超时计数器。</p><ul><li>接收方不是等待自己发送分组才捎带确认，而是立即确认</li><li>发送方只要接到三次重复确认，就立即发送缺失分组</li><li>这样的话，在丢失某个分组时候，不会发生超时重传，而是快重传。</li></ul><p>发送方发送一号分组给接收方，在发送方受到一号分组的确认数据段之前，可以发送该窗口内的二号分组，同样在受到二号分组的确认前就可以发送三号分组，但是由于三号分组丢失，发送四号分组时候，接收方未接收到按序到来的分组，因此在接收到四号分组后，发送2号分组的重复确认，发送方仍然按照规则发送五号和六号分组，接收方受到五号和六号分组后，因为都不是二号分组，任然发送2号重复确认，当发送方受到三次重复确认后，则再发送2号分组。</p></li></ol><h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><ol><li><p>算法：</p><p>在发生超时重传后，不在是将cwnd变为1，而是将ssthresh和cwnd都变成当前拥塞窗口cwnd的一半，然后进入到拥塞避免阶段</p></li></ol><p><img src="https://ae01.alicdn.com/kf/Hfa66d4ae6f9446a3996bd342515d1016W.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;传输层概念&lt;/p&gt;
&lt;p&gt;功能&lt;/p&gt;
&lt;p&gt;UDP和TCP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.arkxkz.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.arkxkz.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>回溯法</title>
    <link href="https://www.arkxkz.com/2020/02/11/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>https://www.arkxkz.com/2020/02/11/回溯法/</id>
    <published>2020-02-11T08:28:51.000Z</published>
    <updated>2020-02-11T08:33:48.762Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回溯法的基本例题</p><p>来自LeetCode回溯法标签</p></blockquote><a id="more"></a><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><blockquote><p>概念：</p><p>本质是一个枚举法，但是需要栈记录之前过程（路程），不满足条件时候，根据记录的路径回溯返回，常尝试另一条路径。与枚举法的区别在于：枚举法每一个答案都需要从头开始判断，回溯法使用栈记录之前的走过的路径，具有相同的前缀答案，重复利用，不需要从头开始查找。</p><p>关键：</p><ul><li>边界条件</li><li>所有可能（分叉的个数）</li><li>回溯</li></ul></blockquote><h2 id="正则表达式的匹配"><a href="#正则表达式的匹配" class="headerlink" title="正则表达式的匹配"></a>正则表达式的匹配</h2><blockquote><p>题干：</p><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p><p>来源：力扣（LeetCode）<br>*<em>详细例子：<a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/</a> *</em></p></blockquote><p><strong>回溯法：——详解</strong></p><p><font color="red">关键：“*”的出现,导致回溯长度不定</font></p><ul><li>简化问题：如果只出现了字母和“.”的递归形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只出现了. 和 字母的模式匹配</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">simplifyMatch</span><span class="params">(String s, String p,<span class="keyword">int</span> sStart,<span class="keyword">int</span> pStart)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pStart &gt;= p.length())<span class="keyword">return</span> sStart == s.length()?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(sStart &lt; s.length() &amp;&amp; (p.charAt(pStart)==s.charAt(sStart) || p.charAt(pStart) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">flag = simplifyMatch(s,p,++sStart,++pStart);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出现“*”后，出现回溯，因为不明确知道星号会让前一个字符重复多少次，消耗多少个字符串的字符</li><li>递归表达式，“*”的可能只有两种，一种是零次，一种是一次。如果应该重复n次，则将之后的可能交给之后处理。</li></ul><p>由于星号的匹配形成的匹配树为：（参考：<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/）</a></p><p><img src="https://pic.images.ac.cn/image/5e2faa777ca72" alt></p><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整的回溯法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backTracing</span><span class="params">(String s,String p,<span class="keyword">int</span> sStart,<span class="keyword">int</span> pStart)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(pStart &lt; p.length() &amp;&amp; p.charAt(pStart) == <span class="string">'*'</span>)pStart++;</span><br><span class="line"><span class="keyword">if</span>(pStart &gt;= p.length())<span class="keyword">return</span> sStart == s.length()?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(pStart + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(pStart+<span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line"><span class="comment">//x*代表空</span></span><br><span class="line">flag = backTracing(s,p,sStart,pStart+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="keyword">false</span> &amp;&amp; sStart &lt; s.length() &amp;&amp; (p.charAt(pStart) == <span class="string">'.'</span> || p.charAt(pStart) == s.charAt(sStart)))flag = backTracing(s,p,sStart+<span class="number">1</span>,pStart);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(sStart &lt; s.length() &amp;&amp; (p.charAt(pStart) == <span class="string">'.'</span> || p.charAt(pStart) == s.charAt(sStart))) &#123;</span><br><span class="line">flag = backTracing(s,p,sStart+<span class="number">1</span>,pStart+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划：</strong></p><ul><li>dp（i，j）表示p从0到i，s从0到j的子串匹配情况，true为匹配，否则为false</li><li>p为字母时：当dp（i-1，j-1）= true 且 p（i）=s（j）时，dp（i，j） = true，否则为false</li><li>p为“.”时：当dp（i-1，j-1）= true ，dp（i，j） = true，否则 dp（i，j）= false</li><li><strong>关键</strong>——p为“*”时：dp（i-2,j) = true 或者 dp（i-1，j）= true 或者preChar = s（j）并且dp(i,j-1) = true，则dp(i,j)= true</li></ul><p>动态规划的简化——在空间上不需要使用n^2，而是2n的大小</p><ul><li>只保留dp（i，j）的最近两行</li><li>注意初始化</li></ul><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]表示p到i长度和s到j长度的匹配情况</span></span><br><span class="line">    <span class="comment">//可以简化为只有两行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>][len];</span><br><span class="line">        <span class="keyword">char</span> preChar = <span class="string">'['</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> turnNum = (i+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">char</span> tmpChar = p.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(tmpChar == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i%<span class="number">2</span>][<span class="number">0</span>]== <span class="keyword">true</span>)   dp[turnNum][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; dp[turnNum][<span class="number">0</span>]==<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">else</span>    dp[turnNum][<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[turnNum][<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmpChar==<span class="string">'.'</span>)&#123;</span><br><span class="line">                    dp[turnNum][j] = dp[i%<span class="number">2</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmpChar==<span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i%<span class="number">2</span>][j]== <span class="keyword">true</span>)   dp[turnNum][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; dp[turnNum][j]==<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[turnNum][j-<span class="number">1</span>] == <span class="keyword">true</span> &amp;&amp; (preChar == <span class="string">'.'</span> || preChar == s.charAt(j-<span class="number">1</span>)))&#123;</span><br><span class="line">                        dp[turnNum][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[turnNum][j] = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i%<span class="number">2</span>][j-<span class="number">1</span>]==<span class="keyword">true</span> &amp;&amp; tmpChar == s.charAt(j-<span class="number">1</span>))  dp[turnNum][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">else</span>    dp[turnNum][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            preChar = tmpChar;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[p.length()%<span class="number">2</span>][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>backTracing效率：</p><p><img src="https://pic.images.ac.cn/image/5e2fa9f756e65" alt></p><p>dp效率：</p><p><img src="https://images.ac.cn/image/5e2e643e2d584" alt></p><hr><hr><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><blockquote><p>题目：</p><p><img src="https://pic.images.ac.cn/image/5e2fac09c80f4" alt></p></blockquote><ul><li>典型的回溯法问题</li><li>回溯路径的分叉就是每个数字可以映射的字母数目</li></ul><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] table = <span class="keyword">new</span> String[]&#123;<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)    <span class="keyword">return</span> lists;</span><br><span class="line">        backTracing(digits,<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(String digits,String list,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= digits.length())&#123;</span><br><span class="line">            lists.add(list.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = digits.charAt(start) - <span class="string">'2'</span>,len = table[num].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            backTracing(digits,list+table[num].charAt(i),start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组组合Ⅰ"><a href="#数组组合Ⅰ" class="headerlink" title="数组组合Ⅰ"></a>数组组合Ⅰ</h2><blockquote><p>题干：</p><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p><p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>[7],<br>[2,2,3]<br>]</p><p>来源：力扣（LeetCode）</p></blockquote><p>*<em>思路 ： *</em></p><ul><li>构建出对应的N叉树</li><li>优化树，进行必要的剪枝</li><li>递归写出关系，想好边界条件</li></ul><p><strong>N叉树</strong></p><p><img src="https://ae01.alicdn.com/kf/U745e0bd403c144b9bc89940c4d06e573Y.png" alt></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录所有可能</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//方便剪枝</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTracing(candidates,target,<span class="number">0</span>,list);</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯法——DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> low,ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            listAll.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low;i&lt;candidates.length &amp;&amp; target - candidates[i] &gt;= <span class="number">0</span>;i++)&#123;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            backTracing(candidates,target-candidates[i],i,list);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率：</p><p><img src="https://ae01.alicdn.com/kf/U1aea22ac3ce9447db9f9892da1f089cbN.png" alt></p><h2 id="数组组合Ⅱ"><a href="#数组组合Ⅱ" class="headerlink" title="数组组合Ⅱ"></a>数组组合Ⅱ</h2><blockquote><p>题干：</p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>[1, 7],<br>[1, 2, 5],<br>[2, 6],<br>[1, 1, 6]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii</a></p></blockquote><p>注意：</p><ol><li>不能够使用重复的元素（给定数组中的数字只能够使用一次）</li><li>不能够有相同的解（给定数组中国可能出现多个相同的数字）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracing(candidates,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//回溯法（深度优先遍历）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lists.contains(list))    lists.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(Integer.valueOf(candidates[i]));</span><br><span class="line">                backTracing(candidates,target - candidates[i],i+<span class="number">1</span>,list);</span><br><span class="line">                list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列Ⅱ"><a href="#全排列Ⅱ" class="headerlink" title="全排列Ⅱ"></a>全排列Ⅱ</h2><blockquote><p>题干：</p><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><p>输入: [1,1,2]<br>输出:<br>[<br>[1,1,2],<br>[1,2,1],<br>[2,1,1]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii</a></p></blockquote><ol><li>构造递归（构建树模型）</li><li>注意去重，很好的提高效率</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;Integer&gt; numList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">            numList.add(Integer.valueOf(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        backTracing(numList,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与数字组合问题Ⅱ相同的回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(List&lt;Integer&gt; nums,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//if(!lists.contains(list))   lists.add(new ArrayList(list));</span></span><br><span class="line">            lists.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums.get(i).equals(nums.get(i-<span class="number">1</span>)))  <span class="keyword">continue</span>;</span><br><span class="line">            Integer tmp = nums.remove(i);</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            backTracing(nums,list);</span><br><span class="line">            nums.add(i,tmp);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N-皇后问题"><a href="#N-皇后问题" class="headerlink" title="N 皇后问题"></a>N 皇后问题</h2><blockquote><p>题干：</p><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="http://pic.images.ac.cn/image/5e38eb5256d07" alt></p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例:</p><p>输入: 4<br>输出: [<br>[“.Q..”,  // 解法 1<br>“…Q”,<br>“Q…”,<br>“..Q.”],</p><p>[“..Q.”,  // 解法 2<br>“Q…”,<br>“…Q”,<br>“.Q..”]<br>]<br>解释: 4 皇后问题存在两个不同的解法。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a></p></blockquote><p>思路：</p><ul><li>回溯法的基本应用</li><li>关键在于“剪枝”——不能放Queen的位置<ul><li>要与以前放的位置进行比较，不能发生冲突</li></ul></li></ul><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) <span class="keyword">return</span> lists;</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backTracingQueen(<span class="number">0</span>,board);</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracingQueen</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">                StringBuffer strBuff = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                    strBuff.append(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(strBuff.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//row 行 i 列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(canPut(board,row,i))&#123;</span><br><span class="line">                board[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">                backTracingQueen(row+<span class="number">1</span>,board);</span><br><span class="line">                board[row][i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPut</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> gap = row - i;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">'Q'</span> || (col - gap &gt;= <span class="number">0</span> &amp;&amp; board[i][col-gap]==<span class="string">'Q'</span>) ||(col + gap &lt; board[<span class="number">0</span>].length &amp;&amp; board[i][col+gap] == <span class="string">'Q'</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N皇后Ⅱ"><a href="#N皇后Ⅱ" class="headerlink" title="N皇后Ⅱ"></a>N皇后Ⅱ</h2><blockquote><p>题干：</p><p>给定一个整数 <em>n</em>，返回 <em>n</em> 皇后不同的解决方案的数量。</p></blockquote><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> backTracingWay(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最简单的方法——直接进行回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backTracingWay</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录每一行放置queen的位置</span></span><br><span class="line">        <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        num+=backTracing(<span class="number">0</span>,pos);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span>  <span class="title">backTracing</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span>[] pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == pos.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; pos.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(canPut(pos,row,i))&#123;</span><br><span class="line">                pos[row] = i;</span><br><span class="line">                num+=backTracing(row+<span class="number">1</span>,pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPut</span><span class="params">(<span class="keyword">int</span>[] pos,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row-<span class="number">1</span>; i&gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos[i] == col || row - i == Math.abs(col - pos[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第K个排列"><a href="#第K个排列" class="headerlink" title="第K个排列"></a>第K个排列</h2><blockquote><p>题干：</p><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p><p>说明：</p><p>给定 n 的范围是 [1, 9]。<br>给定 k 的范围是[1,  n!]。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutation-sequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutation-sequence</a></p></blockquote><p>法一：利用数学排列组合从高到低位确定每一位的数</p><p>法二：回溯法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//回溯的结果</span></span><br><span class="line">    <span class="keyword">private</span> StringBuffer strList = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//DP</span></span><br><span class="line">        <span class="keyword">return</span> dpSolv(n,k);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        List&lt;Character&gt; surplus = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">surplus.add((<span class="keyword">char</span>)(<span class="string">'0'</span> + i));</span><br><span class="line">&#125;</span><br><span class="line">        backTracingK(surplus,<span class="keyword">new</span> ArrayList&lt;&gt;(),k);</span><br><span class="line">        <span class="keyword">return</span> strList.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接根据数学规律</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dpSolv</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = (<span class="keyword">char</span>)(<span class="string">'0'</span> + i);</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> digit = k,divisor = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n;j&gt;<span class="number">1</span>;j--)  divisor *=j;</span><br><span class="line">        StringBuffer strBuff = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            divisor /= (n-i);</span><br><span class="line">            <span class="keyword">int</span> figure =(digit-<span class="number">1</span>)/divisor;</span><br><span class="line">            strBuff.append(list.remove(figure));</span><br><span class="line">            digit -= figure*divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strBuff.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backTracingK</span><span class="params">(List&lt;Character&gt; surplus,List&lt;Character&gt; list, <span class="keyword">int</span> order)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(surplus.size() == <span class="number">0</span>) &#123;</span><br><span class="line">order--;</span><br><span class="line"><span class="keyword">if</span>(order == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(Character tmp: list) &#123;</span><br><span class="line">strList.append(tmp.charValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = surplus.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">list.add(surplus.remove(i));</span><br><span class="line">order = backTracingK(surplus,list,order);</span><br><span class="line"><span class="keyword">if</span>(order == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">surplus.add(i, list.remove(list.size() - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率区别：</p><p>一、数学排列组合</p><p><img src="https://ae01.alicdn.com/kf/H1acde9b79f304530bfa56e876eba2fd1z.png" alt></p><p>二、回溯法</p><p><img src="https://ae01.alicdn.com/kf/Ha5d710bc623143359688066ae78cb1e3Y.png" alt></p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><blockquote><p>题干：</p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:</p><p>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combinations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations</a></p></blockquote><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] surplus = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            surplus[i-<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        backTracing(surplus,<span class="keyword">new</span> ArrayList&lt;&gt;(),<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(<span class="keyword">int</span>[] surplus, List&lt;Integer&gt; list, <span class="keyword">int</span> pos, <span class="keyword">int</span> range)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == range)&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = surplus.length - (range - list.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt;= len; i++ )&#123;</span><br><span class="line">            list.add(Integer.valueOf(surplus[i]));</span><br><span class="line">            backTracing(surplus, list, i+<span class="number">1</span>, range);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集Ⅱ"><a href="#子集Ⅱ" class="headerlink" title="子集Ⅱ"></a>子集Ⅱ</h2><blockquote><p>题干：</p><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><p>输入: [1,2,2]<br>输出:<br>[<br>[2],<br>[1],<br>[1,2,2],<br>[2,2],<br>[1,2],<br>[]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets-ii</a></p></blockquote><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        lists.add(list);</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)    <span class="keyword">return</span> lists;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracing(nums, <span class="number">0</span>, list);</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> pos, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; pos &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            list.add(Integer.valueOf(nums[i]));</span><br><span class="line">            lists.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">            backTracing(nums, i + <span class="number">1</span>, list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单词接龙Ⅱ"><a href="#单词接龙Ⅱ" class="headerlink" title="单词接龙Ⅱ"></a>单词接龙Ⅱ</h2><blockquote><p>题干：</p><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p><pre><code>每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。</code></pre><p>说明:</p><pre><code>如果不存在这样的转换序列，返回一个空列表。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</code></pre><p>示例 1:</p><p>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>输出:<br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-ladder-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder-ii</a></p></blockquote><p>法一：DFS</p><ul><li>每个单词是一个节点</li><li>找出每个节点的扩展节点<ul><li>法一：扫描一遍词典，找到只相差一个字符的单词</li><li>法二：改变单词的每一位从a到z，得到的新单词如果在词典中，作为下一个扩展节点</li></ul></li></ul><p>法二：BFS</p><ul><li>按照DFS，每一个节点的扩展节点都要现场计算，每一个节点的分叉数量太大，导致时间复杂度过高。</li><li>使用BFS得到每个节点的扩展节点，再使用类似DFS得到路径</li><li>优化：<ul><li>可以在BFS的同时记录路径，省去再次进行DFS的时间。搜索树的节点不再是单个单词，而是List，用来记录路径的状态。</li><li>剪枝：当BFS在n层时候，如果扩展单词为前n-1层出现过的单词时候，直接返回。因为该路径不可能是最短路径。</li></ul></li></ul><p>法三：双向BFS+DFS</p><ul><li>双向BFS得到单词之间的关系map（那些单词之间只相差一个单词）</li><li>DFS根据BFS构造出来的树，进行遍历得到最短路径</li></ul><p>DFS：</p><p><img src="https://ae01.alicdn.com/kf/H0d4e1f425a05404184b47ba70d79af40l.png" alt></p><p>BFS：</p><p><img src="https://ae01.alicdn.com/kf/H4fe26cbdee5f4e1d85d2bd7cb42169e6a.png" alt></p><p>双向BFS：</p><p><img src="https://ae01.alicdn.com/kf/H31366eb8517c4f5384a2265157d89434t.png" alt></p><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        <span class="comment">//DFS</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        List&lt;String&gt; path = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        path.add(beginWord);</span></span><br><span class="line"><span class="comment">        backTracing(beginWord, endWord, wordList, path);</span></span><br><span class="line"><span class="comment">        return lists;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HashSet&lt;String&gt; dict = new HashSet(wordList);</span></span><br><span class="line"><span class="comment">        List&lt;List&lt;String&gt;&gt; bfsLists = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        if(!dict.contains(endWord)) return bfsLists;</span></span><br><span class="line"><span class="comment">        BFS (beginWord, endWord, dict, bfsLists);</span></span><br><span class="line"><span class="comment">        return bfsLists;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//double BFS + DFS</span></span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet(wordList), head = <span class="keyword">new</span> HashSet(),tail = <span class="keyword">new</span> HashSet();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; allPath = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span>(!dict.contains(endWord)) <span class="keyword">return</span> allPath;</span><br><span class="line">        head.add(beginWord);</span><br><span class="line">        tail.add(endWord);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(doubleBFS(dict, head, tail, map, <span class="keyword">true</span>))&#123;</span><br><span class="line">            List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            path.add(beginWord);</span><br><span class="line">            dfsGetPath(allPath, path, beginWord, endWord, map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList, List&lt;String&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beginWord.equals(endWord))&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.size() == minDist)   lists.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(path.size() &lt; minDist) &#123;</span><br><span class="line">                minDist = path.size();</span><br><span class="line">                lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                lists.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(wordList.size() == <span class="number">0</span> || path.size() &gt;= minDist)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] diff = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size()];</span><br><span class="line">        getDiffer(beginWord, wordList, diff);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(diff[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                path.add(wordList.get(i));</span><br><span class="line">                backTracing(wordList.remove(i), endWord, wordList, path);</span><br><span class="line">                wordList.add(i,path.remove(path.size() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDiffer</span><span class="params">(String beginWord, List&lt;String&gt; wordList, <span class="keyword">int</span>[] diff)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            String str = wordList.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; beginWord.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(beginWord.charAt(j) != str.charAt(j))    num++;</span><br><span class="line">            &#125;</span><br><span class="line">            diff[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(String beginWord, String endWord, HashSet&lt;String&gt; dict, List&lt;List&lt;String&gt;&gt; lists)</span> </span>&#123;</span><br><span class="line"><span class="comment">//BFS队列，存储多个“路径”</span></span><br><span class="line">Queue&lt;List&lt;String&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(!dict.contains(endWord))<span class="keyword">return</span>;</span><br><span class="line">List&lt;String&gt; beginList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">beginList.add(beginWord);</span><br><span class="line">queue.offer(beginList);</span><br><span class="line"><span class="comment">//访问过的词汇</span></span><br><span class="line">HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line"><span class="comment">//是否达到最短路径的长度</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; flag == <span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> len = queue.size();</span><br><span class="line"><span class="comment">//避免漏算相同层数上的路径，每层单词统一添加到visited中</span></span><br><span class="line">HashSet&lt;String&gt; subSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; len; i++) &#123;</span><br><span class="line">List&lt;String&gt; nowList = queue.poll();</span><br><span class="line">String nowString = nowList.get(nowList.size() - <span class="number">1</span>);</span><br><span class="line">List&lt;String&gt; arr  = getNeighbors(nowString, dict);</span><br><span class="line"><span class="keyword">for</span>(String tmpStr: arr) &#123;</span><br><span class="line"><span class="keyword">if</span>(!visited.contains(tmpStr)) &#123;</span><br><span class="line"><span class="keyword">if</span>(tmpStr.equals(endWord)) &#123;</span><br><span class="line"><span class="comment">//将list加入lists</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">nowList.add(tmpStr);</span><br><span class="line">lists.add(<span class="keyword">new</span> ArrayList(nowList));</span><br><span class="line">nowList.remove(nowList.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将单词加入queue的对应list中</span></span><br><span class="line">nowList.add(tmpStr);</span><br><span class="line">queue.offer(<span class="keyword">new</span> ArrayList(nowList));</span><br><span class="line">nowList.remove(nowList.size() - <span class="number">1</span>);</span><br><span class="line">subSet.add(tmpStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visited.addAll(subSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get the neighbor-node of the current-node</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; set)</span></span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">char</span>[] cs = node.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> old = cs[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == old)<span class="keyword">continue</span>;</span><br><span class="line">cs[i] = c;</span><br><span class="line">String tmp = String.valueOf(cs);</span><br><span class="line"><span class="keyword">if</span>(set.contains(tmp))list.add(tmp);</span><br><span class="line">&#125;</span><br><span class="line">cs[i] = old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//double direction BFS build the tree</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doubleBFS</span><span class="params">(Set&lt;String&gt; dict, Set&lt;String&gt; head, Set&lt;String&gt; tail, Map&lt;String, List&lt;String&gt;&gt; map, <span class="keyword">boolean</span> direction)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//双向构建，始终构建更少的一方</span></span><br><span class="line"><span class="keyword">if</span>(head.size() &gt; tail.size())<span class="keyword">return</span> doubleBFS(dict, tail, head, map, !direction);</span><br><span class="line">dict.removeAll(head);</span><br><span class="line">Set&lt;String&gt; subSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(String str: head) &#123;</span><br><span class="line">List&lt;String&gt; arr = getNeighbors(str, dict);</span><br><span class="line"><span class="keyword">for</span>(String nextStr: arr) &#123;</span><br><span class="line">subSet.add(nextStr);</span><br><span class="line">String key = direction? str: nextStr;</span><br><span class="line">String value = direction? nextStr:str;</span><br><span class="line"><span class="keyword">if</span>(tail.contains(nextStr))flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(key)) &#123;</span><br><span class="line">map.put(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line">map.get(key).add(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="keyword">true</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> doubleBFS(dict, subSet, tail, map, direction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs get the path</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsGetPath</span><span class="params">(List&lt;List&lt;String&gt;&gt; allPath, List&lt;String&gt; path,String beginWord, String endWord, Map&lt;String, List&lt;String&gt;&gt; map)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(beginWord.equals(endWord)) &#123;</span><br><span class="line">allPath.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(beginWord))<span class="keyword">return</span>;</span><br><span class="line">List&lt;String&gt; values = map.get(beginWord);</span><br><span class="line"><span class="keyword">for</span>(String str: values) &#123;</span><br><span class="line">path.add(str);</span><br><span class="line">dfsGetPath(allPath, path, str, endWord, map );</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向BFS+DFS，BFS，DFS的效率：</p><p><img src="https://ae01.alicdn.com/kf/Ha7ecfe3ca04b41218fe96de2e6e18255K.png" alt></p><h2 id="数独求解"><a href="#数独求解" class="headerlink" title="数独求解"></a>数独求解</h2><blockquote><p>题干：</p><p>编写一个程序，通过已填充的空格来解决数独问题。</p><p>一个数独的解法需遵循如下规则：</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>空白格用 ‘.’ 表示。</p></blockquote><p><img src="https://ae01.alicdn.com/kf/Ud4a90729e94e47f2b1a8d8de36dfd2e2f.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基于回溯法填充</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="comment">//分别记录每行，每列，每九宫格使用过的元素</span></span><br><span class="line">        Set[] rowUsed = <span class="keyword">new</span> HashSet[board.length];</span><br><span class="line">        Set[] colUsed = <span class="keyword">new</span> HashSet[board.length];</span><br><span class="line">        Set[] boxUsed = <span class="keyword">new</span> HashSet[board.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            rowUsed[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            colUsed[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            boxUsed[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    rowUsed[i].add(board[i][j]);</span><br><span class="line">                    colUsed[j].add(board[i][j]);</span><br><span class="line">                    boxUsed[(i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span>].add(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backTracing(board,rowUsed,colUsed,boxUsed,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backTracing</span><span class="params">(<span class="keyword">char</span>[][] board,Set[] rowUsed,Set[] colUsed,Set[] boxUsed,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col == board[<span class="number">0</span>].length)&#123;</span><br><span class="line">            row++;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(board[row][col] == <span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> tmp  =(<span class="keyword">char</span>)(<span class="number">49</span> + i) ;</span><br><span class="line">                <span class="keyword">if</span>(!rowUsed[row].contains(tmp) &amp;&amp; !colUsed[col].contains(tmp) &amp;&amp; !boxUsed[(row/<span class="number">3</span>)*<span class="number">3</span> + col/<span class="number">3</span>].contains(tmp))&#123;</span><br><span class="line">                    rowUsed[row].add(tmp);</span><br><span class="line">                    colUsed[col].add(tmp);</span><br><span class="line">                    boxUsed[(row/<span class="number">3</span>)*<span class="number">3</span> + col/<span class="number">3</span>].add(tmp);</span><br><span class="line">                    <span class="keyword">if</span>(backTracing(board,rowUsed,colUsed,boxUsed,row,col+<span class="number">1</span>))&#123;</span><br><span class="line">                        board[row][col] = tmp;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        rowUsed[row].remove(tmp);</span><br><span class="line">                        colUsed[col].remove(tmp);</span><br><span class="line">                        boxUsed[(row/<span class="number">3</span>)*<span class="number">3</span> + col/<span class="number">3</span>].remove(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> backTracing(board,rowUsed,colUsed,boxUsed,row,col+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;回溯法的基本例题&lt;/p&gt;
&lt;p&gt;来自LeetCode回溯法标签&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.arkxkz.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://www.arkxkz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>双向搜索</title>
    <link href="https://www.arkxkz.com/2020/02/11/%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2/"/>
    <id>https://www.arkxkz.com/2020/02/11/双向搜索/</id>
    <published>2020-02-11T04:21:45.000Z</published>
    <updated>2020-02-11T04:27:04.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>双向搜索：降低直接搜索的复杂度<br>双向BFS：单词接龙Ⅱ</p></blockquote><a id="more"></a><h1 id="双向搜索"><a href="#双向搜索" class="headerlink" title="双向搜索"></a>双向搜索</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>双向搜索又叫折半搜索。当搜索的复杂度随着搜索深度指数上升时候，我们可以将指数折半的方法来降低复杂度。也就是将时间复杂度为O$(n^k)$ 降低为时间复杂度为2O$ (n^(k))$。</p><h2 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h2><ol><li>知道开始状态和结束状态</li><li>在每个节点的分叉过多，导致单向搜索时间复杂度过大</li></ol><h2 id="双向广度优先算法"><a href="#双向广度优先算法" class="headerlink" title="双向广度优先算法"></a>双向广度优先算法</h2><blockquote><p>广度优先算法从起始节点开始，按照广度优先遍历的顺序依次扩展每一个节点。</p><p>双向广度优先算法从两个方向，分别按照广度优先遍历顺序扩展子节点。一个初始节点是开始节点，另一个初始节点是目标节点，开始节点向目标节点进行广度优先扩展（up ——down），目标节点（down——up）</p></blockquote><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>双向BFS明显减少复杂度</li><li>广度优先的顺序确保了找到的初始节点到结束节点就是两个节点之间的最短路劲</li></ol><h3 id="例题（单词接龙Ⅱ）"><a href="#例题（单词接龙Ⅱ）" class="headerlink" title="例题（单词接龙Ⅱ）"></a>例题（单词接龙Ⅱ）</h3><blockquote><p>题干：</p><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:</p><p>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p><p>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>输出:<br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-ladder-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder-ii</a></p></blockquote><p>DFS：</p><p><img src="https://ae01.alicdn.com/kf/H0d4e1f425a05404184b47ba70d79af40l.png" alt></p><p>BFS：</p><p><img src="https://ae01.alicdn.com/kf/H4fe26cbdee5f4e1d85d2bd7cb42169e6a.png" alt></p><p>双向BFS：</p><p><img src="https://ae01.alicdn.com/kf/H31366eb8517c4f5384a2265157d89434t.png" alt></p><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        <span class="comment">//DFS</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        List&lt;String&gt; path = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        path.add(beginWord);</span></span><br><span class="line"><span class="comment">        backTracing(beginWord, endWord, wordList, path);</span></span><br><span class="line"><span class="comment">        return lists;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HashSet&lt;String&gt; dict = new HashSet(wordList);</span></span><br><span class="line"><span class="comment">        List&lt;List&lt;String&gt;&gt; bfsLists = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        if(!dict.contains(endWord)) return bfsLists;</span></span><br><span class="line"><span class="comment">        BFS (beginWord, endWord, dict, bfsLists);</span></span><br><span class="line"><span class="comment">        return bfsLists;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//double BFS + DFS</span></span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet(wordList), head = <span class="keyword">new</span> HashSet(),tail = <span class="keyword">new</span> HashSet();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; allPath = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span>(!dict.contains(endWord)) <span class="keyword">return</span> allPath;</span><br><span class="line">        head.add(beginWord);</span><br><span class="line">        tail.add(endWord);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(doubleBFS(dict, head, tail, map, <span class="keyword">true</span>))&#123;</span><br><span class="line">            List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            path.add(beginWord);</span><br><span class="line">            dfsGetPath(allPath, path, beginWord, endWord, map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList, List&lt;String&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beginWord.equals(endWord))&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.size() == minDist)   lists.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(path.size() &lt; minDist) &#123;</span><br><span class="line">                minDist = path.size();</span><br><span class="line">                lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                lists.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(wordList.size() == <span class="number">0</span> || path.size() &gt;= minDist)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] diff = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size()];</span><br><span class="line">        getDiffer(beginWord, wordList, diff);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(diff[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                path.add(wordList.get(i));</span><br><span class="line">                backTracing(wordList.remove(i), endWord, wordList, path);</span><br><span class="line">                wordList.add(i,path.remove(path.size() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDiffer</span><span class="params">(String beginWord, List&lt;String&gt; wordList, <span class="keyword">int</span>[] diff)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            String str = wordList.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; beginWord.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(beginWord.charAt(j) != str.charAt(j))    num++;</span><br><span class="line">            &#125;</span><br><span class="line">            diff[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(String beginWord, String endWord, HashSet&lt;String&gt; dict, List&lt;List&lt;String&gt;&gt; lists)</span> </span>&#123;</span><br><span class="line"><span class="comment">//BFS队列，存储多个“路径”</span></span><br><span class="line">Queue&lt;List&lt;String&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(!dict.contains(endWord))<span class="keyword">return</span>;</span><br><span class="line">List&lt;String&gt; beginList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">beginList.add(beginWord);</span><br><span class="line">queue.offer(beginList);</span><br><span class="line"><span class="comment">//访问过的词汇</span></span><br><span class="line">HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line"><span class="comment">//是否达到最短路径的长度</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; flag == <span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> len = queue.size();</span><br><span class="line"><span class="comment">//避免漏算相同层数上的路径，每层单词统一添加到visited中</span></span><br><span class="line">HashSet&lt;String&gt; subSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; len; i++) &#123;</span><br><span class="line">List&lt;String&gt; nowList = queue.poll();</span><br><span class="line">String nowString = nowList.get(nowList.size() - <span class="number">1</span>);</span><br><span class="line">List&lt;String&gt; arr  = getNeighbors(nowString, dict);</span><br><span class="line"><span class="keyword">for</span>(String tmpStr: arr) &#123;</span><br><span class="line"><span class="keyword">if</span>(!visited.contains(tmpStr)) &#123;</span><br><span class="line"><span class="keyword">if</span>(tmpStr.equals(endWord)) &#123;</span><br><span class="line"><span class="comment">//将list加入lists</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">nowList.add(tmpStr);</span><br><span class="line">lists.add(<span class="keyword">new</span> ArrayList(nowList));</span><br><span class="line">nowList.remove(nowList.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将单词加入queue的对应list中</span></span><br><span class="line">nowList.add(tmpStr);</span><br><span class="line">queue.offer(<span class="keyword">new</span> ArrayList(nowList));</span><br><span class="line">nowList.remove(nowList.size() - <span class="number">1</span>);</span><br><span class="line">subSet.add(tmpStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visited.addAll(subSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get the neighbor-node of the current-node</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; set)</span></span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">char</span>[] cs = node.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> old = cs[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == old)<span class="keyword">continue</span>;</span><br><span class="line">cs[i] = c;</span><br><span class="line">String tmp = String.valueOf(cs);</span><br><span class="line"><span class="keyword">if</span>(set.contains(tmp))list.add(tmp);</span><br><span class="line">&#125;</span><br><span class="line">cs[i] = old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//double direction BFS build the tree</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doubleBFS</span><span class="params">(Set&lt;String&gt; dict, Set&lt;String&gt; head, Set&lt;String&gt; tail, Map&lt;String, List&lt;String&gt;&gt; map, <span class="keyword">boolean</span> direction)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//双向构建，始终构建更少的一方</span></span><br><span class="line"><span class="keyword">if</span>(head.size() &gt; tail.size())<span class="keyword">return</span> doubleBFS(dict, tail, head, map, !direction);</span><br><span class="line">dict.removeAll(head);</span><br><span class="line">Set&lt;String&gt; subSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(String str: head) &#123;</span><br><span class="line">List&lt;String&gt; arr = getNeighbors(str, dict);</span><br><span class="line"><span class="keyword">for</span>(String nextStr: arr) &#123;</span><br><span class="line">subSet.add(nextStr);</span><br><span class="line">String key = direction? str: nextStr;</span><br><span class="line">String value = direction? nextStr:str;</span><br><span class="line"><span class="keyword">if</span>(tail.contains(nextStr))flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(key)) &#123;</span><br><span class="line">map.put(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line">map.get(key).add(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="keyword">true</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> doubleBFS(dict, subSet, tail, map, direction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs get the path</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsGetPath</span><span class="params">(List&lt;List&lt;String&gt;&gt; allPath, List&lt;String&gt; path,String beginWord, String endWord, Map&lt;String, List&lt;String&gt;&gt; map)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(beginWord.equals(endWord)) &#123;</span><br><span class="line">allPath.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(beginWord))<span class="keyword">return</span>;</span><br><span class="line">List&lt;String&gt; values = map.get(beginWord);</span><br><span class="line"><span class="keyword">for</span>(String str: values) &#123;</span><br><span class="line">path.add(str);</span><br><span class="line">dfsGetPath(allPath, path, str, endWord, map );</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向BFS+DFS，BFS，DFS的效率：</p><p><img src="https://ae01.alicdn.com/kf/Ha7ecfe3ca04b41218fe96de2e6e18255K.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;双向搜索：降低直接搜索的复杂度&lt;br&gt;双向BFS：单词接龙Ⅱ&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.arkxkz.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://www.arkxkz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_刷题第二三周</title>
    <link href="https://www.arkxkz.com/2020/01/18/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%AC%E4%BA%8C%E4%B8%89%E5%91%A8/"/>
    <id>https://www.arkxkz.com/2020/01/18/LeetCode-刷题第二三周/</id>
    <published>2020-01-18T14:14:25.000Z</published>
    <updated>2020-01-18T14:17:41.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LeetCode刷题第二，三周部分题目<br>主要涉及部分动态规划</p></blockquote><a id="more"></a><h1 id="快慢指针问题："><a href="#快慢指针问题：" class="headerlink" title="快慢指针问题："></a>快慢指针问题：</h1><h2 id="寻找重复数字"><a href="#寻找重复数字" class="headerlink" title="寻找重复数字"></a>寻找重复数字</h2><blockquote><p>题干：</p><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>示例 1:</p><p>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:</p><p>输入: [3,1,3,4,2]<br>输出: 3<br>说明：</p><p>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 O(1) 的空间。<br>时间复杂度小于 O(n2) 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。</p><p>来源：力扣（LeetCode）</p></blockquote><p><strong>二分法</strong></p><ul><li>low =1，high= n</li><li>low&lt;high<ul><li>mid=（low+high）/2</li><li>count=小于等于mid的元素个数</li><li>count&gt;mid：high=mid</li><li>count&lt;=mid：low=mid+1</li></ul></li><li>return low</li></ul><p><strong>快慢指针</strong></p><ul><li>数组下标为元素位置</li><li>数组元素内容为链表下一个元素位置</li><li>存在重复数字=存在环</li><li>找到环的起始地址<ul><li>使用快慢指针，一定相遇在环的某个位置，此时slow相对于初始位置凑了N，相对于环的开始位置走了N-M</li><li>因此让slow再走M步，它相对于环的开始节点也走了N步</li><li>因为fast走了2N步，slow走了N步，相差的部署N一定是环的长度的整数倍。</li><li>因此slow相对于环起始点走了N步，一定会走到环的初始节点</li></ul></li></ul><p><img src="https://ae01.alicdn.com/kf/U0a338dd4939b466f93c68ea1c77204deN.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return splitMid(nums);</span></span><br><span class="line">        <span class="keyword">return</span> slowAndFast(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找中点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitMid</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;=mid)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;mid)&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slowAndFast</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow =nums[<span class="number">0</span>],fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> reset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(reset != slow)&#123;</span><br><span class="line">            reset = nums[reset];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><blockquote><p>题干：</p><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p+gap &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p+gap]==<span class="number">0</span>)&#123;</span><br><span class="line">                gap++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[p] = nums[p+gap];</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p &lt; nums.length)&#123;</span><br><span class="line">            nums[p++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常规动态规划"><a href="#常规动态规划" class="headerlink" title="常规动态规划"></a>常规动态规划</h1><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><blockquote><p>题干：</p><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>示例 1:</p><p>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.<br>示例 2:</p><p>输入: n = 13<br>输出: 2<br>解释: 13 = 4 + 9.</p><p>来源：力扣（LeetCode）</p></blockquote><p>典型的动态规划：</p><ul><li><p>F（i） = i；（i从0到n）</p></li><li><p>F（n）=Min（F（n-j×j）+1，F（n））</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">           dp[i] = i;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i-j*j&gt;=<span class="number">0</span>;j++)&#123;</span><br><span class="line">               dp[i] = Math.min(dp[i],dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a>最大正方形</h2><blockquote><p>题干：</p><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><p>输入: </p><p>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p><p>输出: 4</p><p>来源：力扣（LeetCode）</p></blockquote><p>思路一：</p><ul><li>类似于计算最大的矩形</li><li>使用顺序栈，计算面积</li><li>面积不再是长×宽，而是Min（长，宽）×Min（长，宽）</li></ul><p>思路二：</p><ul><li>使用动态规划思想</li><li>dp（i，j） = 1 + Min（dp（i-1，j-1），dp（i-1，j），dp（i，j-1））</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> MaxSquare = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dpSolution(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用顺序栈得到最大面积——不是最优</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">useStack</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//我们将nums看成一个记录柱状图高度的数组</span></span><br><span class="line">        <span class="comment">//传递给顺序栈算法计算最大的正方形体积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] != <span class="string">'0'</span>)&#123;</span><br><span class="line">                    nums[j] += <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    nums[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            getMaxSquare(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.MaxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMaxSquare</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            heights[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        heights[nums.length] = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()]&gt;heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> left = stack.isEmpty()?-<span class="number">1</span>:stack.peek();</span><br><span class="line">                <span class="keyword">int</span> side = Math.min(heights[pos],i-left-<span class="number">1</span>);</span><br><span class="line">                MaxSquare = Math.max(MaxSquare,side*side);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用DP</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpSolution</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] sideLens = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; matrix[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            sideLens[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i] == <span class="string">'1'</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            maxLength = Math.max(maxLength,sideLens[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            sideLens[i%<span class="number">2</span>][<span class="number">0</span>] = matrix[i][<span class="number">0</span>]==<span class="string">'1'</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            maxLength = Math.max(maxLength,sideLens[i%<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    sideLens[i%<span class="number">2</span>][j] =<span class="number">1</span> + Math.min(sideLens[(i-<span class="number">1</span>)%<span class="number">2</span>][j-<span class="number">1</span>],Math.min(sideLens[i%<span class="number">2</span>][j-<span class="number">1</span>],sideLens[(i-<span class="number">1</span>)%<span class="number">2</span>][j]));</span><br><span class="line">                    maxLength = Math.max(maxLength,sideLens[i%<span class="number">2</span>][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sideLens[i%<span class="number">2</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength*maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乘积最大子序列"><a href="#乘积最大子序列" class="headerlink" title="乘积最大子序列"></a>乘积最大子序列</h2><blockquote><p>题干：</p><p>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><p>示例 1:</p><p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p><p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p><p>来源：力扣（LeetCode）</p></blockquote><p><font color="red" size="4">关键：</font></p><ul><li><p>简单化的思考：</p><ul><li>一个序列全部正数，问最大连续积为多少？</li><li>直接相乘到最后一个数</li></ul></li><li><p>有正有负的序列？</p><ul><li>也要相乘到最后一个数据，前n-1个数相乘可能不是正数，可能是负数，根据是否同号，f（n-1）可能是前n-1的最小（负）连续积，也可能最大（正）连续积</li></ul></li><li><p>是一个动态规划问题</p><ul><li>关键在于找出F（N）与F（N-1）之间的关系</li></ul></li><li><p>关键步骤在于记录前n-1项积的连续积到底是正数（最大）还是最小（负）还是0</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxNum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] repo = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;<span class="number">0</span>)   repo[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt; <span class="number">0</span>)    repo[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            updateRepo(repo,nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                maxNum = Math.max(maxNum,nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                maxNum = Math.max(maxNum,repo[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(repo[<span class="number">0</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    maxNum = Math.max(maxNum,repo[<span class="number">0</span>]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    maxNum = Math.max(maxNum,repo[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRepo</span><span class="params">(<span class="keyword">int</span>[] repo,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            tmp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            tmp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(repo[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                tmp[<span class="number">0</span>] = num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[<span class="number">0</span>] = repo[<span class="number">0</span>]*num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(repo[<span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                tmp[<span class="number">1</span>] = repo[<span class="number">1</span>]*num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(repo[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                tmp[<span class="number">1</span>] = num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[<span class="number">1</span>] = num*repo[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[<span class="number">0</span>] = num*repo[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        repo[<span class="number">0</span>] = tmp[<span class="number">0</span>];</span><br><span class="line">        repo[<span class="number">1</span>] = tmp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><blockquote><p>题干：</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 2:</p><p>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p>来源：力扣（LeetCode）</p></blockquote><p><font color="red" size="4">解题思路：</font></p><ul><li>影响结果的是每一家偷还是不偷</li><li>如果偷：这次偷的结果 = 上次没偷 + 这家的财报</li><li><strong>如果不偷</strong>：这次的结果 = MAX（上次投了，上次没偷）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//动态规划，保存两个值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> didSteal=<span class="number">0</span>,notSteal=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpYes = notSteal + nums[i];</span><br><span class="line">            <span class="keyword">int</span> tmpNo = Math.max(didSteal,notSteal);</span><br><span class="line">            didSteal = tmpYes;</span><br><span class="line">            notSteal = tmpNo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(didSteal,notSteal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口问题："><a href="#滑动窗口问题：" class="headerlink" title="滑动窗口问题："></a>滑动窗口问题：</h1><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><blockquote><p>题干：</p><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p></blockquote><p><strong>动态规划解决：</strong></p><ul><li>将原来数组按照窗口大小划分成多个分组</li><li>用两个同样大小的数组记录每个分组从开始到该位置的最大值，结束到该位置的最大值</li><li>考虑窗口可能在两个分组之间，两个窗口各占一部分。</li><li>输出的最大值就是MAX（right（i），left（i+k-1））</li></ul><p>构造如图所示：</p><p><img src="https://ae01.alicdn.com/kf/Ue32468901a914ffda80d8e5ccf27b810v.png" alt></p><p>构造左数组和右数组一定要注意：</p><p><img src="https://ae01.alicdn.com/kf/Uc056f0c82bb241b6a0c2d49e8af576fb6.png" alt></p><p><strong>双端队列解法</strong></p><ul><li>每次放入的元素，必须保证队列里面所有的元素都大于要放入的元素（因为每次输出只可能是那个更大的元素）</li><li>每次判断最先放入的元素序号与即将放入元素序号差值与窗口大小的关系，如果大于等于必须从头部删除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//return dpSolution(nums,k);</span></span><br><span class="line">        <span class="keyword">return</span> queueSolution(nums,k);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dpSolution(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> maxLeft=Integer.MIN_VALUE,maxRight=Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//注意这样直接将左右视为一谈是错误的</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;nums.length;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(i%k == 0)&#123;</span></span><br><span class="line">        <span class="comment">//         maxLeft = nums[i];</span></span><br><span class="line">        <span class="comment">//         maxRight = nums[nums.length-1-i];</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         maxLeft = Math.max(maxLeft,nums[i]);</span></span><br><span class="line">        <span class="comment">//         maxRight = Math.max(maxRight,nums[nums.length-1-i]);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     left[i] = maxLeft;</span></span><br><span class="line">        <span class="comment">//     right[nums.length-1-i] = maxRight;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//正确是将左右分别处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//left</span></span><br><span class="line">            <span class="keyword">if</span>(i%k ==<span class="number">0</span>)&#123;</span><br><span class="line">                maxLeft = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxLeft = Math.max(maxLeft,nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = maxLeft;</span><br><span class="line">            <span class="comment">//right</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.length-<span class="number">1</span>-i;</span><br><span class="line">            <span class="keyword">if</span>(j%k ==<span class="number">0</span>)&#123;</span><br><span class="line">                maxRight = nums[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxRight = Math.max(maxRight,nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            right[j] = maxRight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;output.length;i++)&#123;</span><br><span class="line">            output[i] = Math.max(right[i],left[i+k-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//削减双端队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearQueue</span><span class="params">(Deque&lt;Integer&gt; queue,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//最早入栈元素是否应该出栈</span></span><br><span class="line">        <span class="keyword">if</span>(!queue.isEmpty() &amp;&amp; queue.getFirst().intValue()&lt;= i-k)&#123;</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将双端队列中所有比即将进队元素小的元素删除，因为这次输出不可能是它们</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[i]&gt;nums[queue.getLast()])&#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类似构造大根堆——使用双端队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] queueSolution(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">//进行初始化双端队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            clearQueue(queue,nums,i,k);</span><br><span class="line">            queue.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k-<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            clearQueue(queue,nums,i,k);</span><br><span class="line">            queue.offerLast(i);</span><br><span class="line">            output[i-k+<span class="number">1</span>] = nums[queue.getFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速度差异：</p><p>双端队列：</p><p><img src="https://ae01.alicdn.com/kf/U1e7e9aa1ca0340e89bedf29da8090fb4s.png" alt></p><p>动态规划：</p><p><img src="https://ae01.alicdn.com/kf/U56731678e60f422183af3426016586db7.png" alt></p><h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><blockquote><p>题干：</p><p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><p>示例:</p><p>输入: [1,2,3,4]<br>输出: [24,12,8,6]<br>说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><p>进阶：<br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历两次，分别算出左边的乘积和右边的乘积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//左边的乘积</span></span><br><span class="line">        output[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">            output[i] = output[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//乘以右边</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            output[i] *= right;</span><br><span class="line">            right*=nums[i];<span class="comment">//下一次的右边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树的问题"><a href="#树的问题" class="headerlink" title="树的问题"></a>树的问题</h1><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote><p>题干：</p><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><p>4</p><p>/   <br>2     7<br>/ \   / <br>1   3 6   9<br>输出：</p><p>4</p><p>/   <br>7     2<br>/ \   / <br>9   6 3   1</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode leftNode = invertTree(root.left);</span><br><span class="line">            TreeNode rightNode = invertTree(root.right);</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            root.right = leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><blockquote><p>题干：</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>来源：力扣（LeetCode）</p></blockquote><p><img src="https://ae01.alicdn.com/kf/U21acb611b4e54702bbe8698e54a24d8eb.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//后序遍历栈中元素就是一个元素的所有祖先</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stackp = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stackq = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> depthP = postTravel(root,p,stackp);</span><br><span class="line">        <span class="keyword">int</span> depthQ = postTravel(root,q,stackq);</span><br><span class="line">        <span class="keyword">while</span>(depthP&gt;depthQ)&#123;</span><br><span class="line">            stackp.pop();</span><br><span class="line">            depthP--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(depthQ&gt;depthP)&#123;</span><br><span class="line">            stackq.pop();</span><br><span class="line">            depthQ--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(stackp.peek() != stackq.peek())&#123;</span><br><span class="line">            stackp.pop();</span><br><span class="line">            stackq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackp.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postTravel</span><span class="params">(TreeNode root,TreeNode key,Stack&lt;TreeNode&gt; stack)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        TreeNode p = root,pVisited = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                depth++;</span><br><span class="line">                p=p.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(p.right==<span class="keyword">null</span> || pVisited == p.right)&#123;</span><br><span class="line">                    p = stack.pop();</span><br><span class="line">                    depth--;</span><br><span class="line">                    <span class="keyword">if</span>(p == key)&#123;</span><br><span class="line">                        stack.push(p);</span><br><span class="line">                        <span class="keyword">return</span> depth;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pVisited = p;</span><br><span class="line">                    p = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    p = p.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀树的构造"><a href="#前缀树的构造" class="headerlink" title="前缀树的构造"></a>前缀树的构造</h2><blockquote><p>题干：</p><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例:</p><p>Trie trie = new Trie();</p><p>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false<br>trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 true<br>说明:</p><p>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p><p>来源：力扣（LeetCode）</p></blockquote><p><strong>关键</strong></p><ul><li>终止节点的设置</li><li>加入apple之后询问app表示没有</li><li>加入app和apple后询问app表示有</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;   <span class="comment">//代表是否是尾节点</span></span><br><span class="line">    <span class="keyword">private</span> Trie[] next;    <span class="comment">//分别代表a-z</span></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        next = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            next[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Trie pointer = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = word.charAt(i)-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(pointer.next[tmp]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                Trie p = <span class="keyword">new</span> Trie();</span><br><span class="line">                p.flag = <span class="keyword">false</span>;</span><br><span class="line">                pointer.next[tmp] = p;</span><br><span class="line">            &#125;</span><br><span class="line">            pointer = pointer.next[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">        pointer.flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie pointer = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = word.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(pointer.next[tmp] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pointer = pointer.next[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pointer.flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie pointer = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prefix.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = prefix.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(pointer.next[tmp] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pointer = pointer.next[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><blockquote><p>题干：</p><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br>示例:</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p><p>来源：力扣（LeetCode）</p></blockquote><p><strong>关键：pop（）时删除元素后，调整小根堆的位置</strong></p><ul><li>stack表示为最普通的陷入后出的栈</li><li>minpile这个模拟堆表示一个小根堆</li><li>关键要将最小元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用小根堆</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; minPile = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minPile.add(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        minPile.add(x);</span><br><span class="line">        <span class="keyword">int</span> pos = minPile.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&gt;<span class="number">1</span> &amp;&amp; minPile.get(pos)&lt;minPile.get(pos/<span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = minPile.get(pos);</span><br><span class="line">            minPile.set(pos,minPile.get(pos/<span class="number">2</span>));</span><br><span class="line">            minPile.set(pos/<span class="number">2</span>,tmp);</span><br><span class="line">            pos /=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer aim = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;pos&lt;minPile.size() &amp;&amp; !minPile.get(pos).equals(aim);pos++);</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">2</span>*pos;</span><br><span class="line">        minPile.set(pos,minPile.get(minPile.size()-<span class="number">1</span>));</span><br><span class="line">        minPile.remove(minPile.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; minPile.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur+<span class="number">1</span> &lt; minPile.size() &amp;&amp; minPile.get(cur+<span class="number">1</span>).intValue() &lt; minPile.get(cur).intValue())&#123;</span><br><span class="line">                cur = cur +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minPile.get(cur).intValue() &gt;= minPile.get(cur/<span class="number">2</span>).intValue())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = minPile.get(cur);</span><br><span class="line">            minPile.set(cur,minPile.get(cur/<span class="number">2</span>));</span><br><span class="line">            minPile.set(cur/<span class="number">2</span>,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minPile.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>## </p><h1 id="图的问题"><a href="#图的问题" class="headerlink" title="图的问题"></a>图的问题</h1><h2 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h2><blockquote><p>题干：</p><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p>示例 1:</p><p>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。<br>示例 2:</p><p>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。<br>说明:</p><p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。<br>提示:</p><p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。<br>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。<br>拓扑排序也可以通过 BFS 完成。</p></blockquote><p><strong>本质——拓扑排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"><span class="comment">//每个节点的入度</span></span><br><span class="line">        <span class="keyword">int</span>[] graph = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            graph[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">            graph[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prerequisites[i][<span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; graph[prerequisites[i][<span class="number">1</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> adjust = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">                    prerequisites[i][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                    graph[prerequisites[i][<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;prerequisites.length;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(prerequisites[j][<span class="number">1</span>]==adjust)&#123;</span><br><span class="line">                            prerequisites[j][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                            graph[prerequisites[j][<span class="number">0</span>]]--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prerequisites[i][<span class="number">1</span>] != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="其余类别"><a href="#其余类别" class="headerlink" title="其余类别"></a>其余类别</h1><h2 id="搜索二维数组Ⅱ"><a href="#搜索二维数组Ⅱ" class="headerlink" title="搜索二维数组Ⅱ"></a>搜索二维数组Ⅱ</h2><blockquote><p>题干：</p><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>[1,   4,  7, 11, 15],<br>[2,   5,  8, 12, 19],<br>[3,   6,  9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return directSearch(matrix,target);</span></span><br><span class="line">        <span class="keyword">return</span> simpleSearch(matrix,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">directSearch</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == target)  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从右上角开始寻找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">simpleSearch</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>)    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>,col = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;matrix.length &amp;&amp; col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &lt; target)&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><blockquote><p>题干：</p><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">&gt; 输出: <span class="keyword">false</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>示例 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">&gt; 输出: <span class="keyword">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return eliminateStack(head);</span></span><br><span class="line">        <span class="keyword">return</span> judgeList(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">eliminateStack</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.pop().intValue() != head.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接空间复杂度为O（1）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next==<span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len =<span class="number">0</span>;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head2 = head,root = <span class="keyword">new</span> ListNode(-<span class="number">1</span>),mid=head;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>+len)/<span class="number">2</span>;i++)    head2 = head2.next;</span><br><span class="line">        p=head;</span><br><span class="line">        root.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            mid = p;</span><br><span class="line">            p=p.next;</span><br><span class="line">            mid.next = root.next;</span><br><span class="line">            root.next = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(mid!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid.val != head2.val)    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中的第K最大元素"><a href="#数组中的第K最大元素" class="headerlink" title="数组中的第K最大元素"></a>数组中的第K最大元素</h2><blockquote><p>题干：</p><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(nums,low,high);</span><br><span class="line">        <span class="keyword">while</span>(pivot != k-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pivot&lt;k-<span class="number">1</span>)&#123;</span><br><span class="line">                pivot = partition(nums,pivot+<span class="number">1</span>,high);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pivot = partition(nums,low,pivot-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(high&gt;low &amp;&amp; nums[high]&lt;=pivot) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&gt;=pivot) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><blockquote><p>题干：</p><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><p>输入: [3,2,3]<br>输出: 3<br>示例 2:</p><p>输入: [2,2,1,1,1,2,2]<br>输出: 2</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> influ = <span class="number">1</span>, elem= nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == elem)&#123;</span><br><span class="line">                influ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                influ--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(influ == <span class="number">0</span>)&#123;</span><br><span class="line">                elem = nums[i];</span><br><span class="line">                influ = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><blockquote><p>题干：</p><p><img src="https://ae01.alicdn.com/kf/U72a2ed0b65d14502aa6e2bfea8575a87U.png" alt></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line">        ListNode p1 = headA,p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = headA;</span><br><span class="line">        p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(len1&gt;len2)&#123;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">            len1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(len2&gt;len1)&#123;</span><br><span class="line">            p2=p2.next;</span><br><span class="line">            len2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 !=<span class="keyword">null</span> &amp;&amp; p1!=p2)&#123;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">            p2=p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><blockquote><p>题干：</p><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:</p><p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4<br>示例 2:</p><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p><p>来源：力扣（LeetCode）</p></blockquote><ul><li>本质：<ul><li>合并排序</li><li>buttom-to-up的迭代代替递归</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> combieSort(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">combieSort</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        root.next = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode p= head;p!=<span class="keyword">null</span>;p=p.next)&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i代表合并前两个有序链表的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            ListNode pre = root;<span class="comment">//合并端点的父节点</span></span><br><span class="line">            ListNode node = pre.next;<span class="comment">//开始合并的左端点</span></span><br><span class="line">            <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ListNode left = node;</span><br><span class="line">                ListNode right = cutList(left,i);</span><br><span class="line">                node = cutList(right,i);<span class="comment">//下一个要合并的左起点</span></span><br><span class="line">                pre.next = merge(left,right);</span><br><span class="line">                <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将list  cut 前n个元素，返回n后的头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">cutList</span><span class="params">(ListNode head,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(--n&gt;<span class="number">0</span> &amp;&amp; head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LeetCode刷题第二，三周部分题目&lt;br&gt;主要涉及部分动态规划&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.arkxkz.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://www.arkxkz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_刷题第一周</title>
    <link href="https://www.arkxkz.com/2019/12/28/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <id>https://www.arkxkz.com/2019/12/28/LeetCode-刷题第一周/</id>
    <published>2019-12-28T05:24:14.000Z</published>
    <updated>2019-12-28T07:33:44.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>寻找两个有序数组的中位数<br>寻找最长回文子串<br>Z变换<br>水池问题<br>三数之和<br>删除链表倒数第n个节点<br>括号匹配问题<br>交换链表的节点<br>查找元素在排序数组中的开始位置和结束位置<br>实现子串的查找<br>下一个排列<br>数独问题</p></blockquote><a id="more"></a><hr><h1 id="寻找两个有序数组的中位数"><a href="#寻找两个有序数组的中位数" class="headerlink" title="寻找两个有序数组的中位数"></a>寻找两个有序数组的中位数</h1><blockquote><p>思想：</p><ol><li>将两个数组看为一个数组，找中位数就等于找总排序完的len/2位置，或者中间两数的平均数。</li><li>两个序列拿出前 k/2  舍去，这部分是一定不可能的。剩下二序列头元素更小的哪一个就是要求中位数</li><li>但是存在一个数组的长度不够k/2的情况，因此如果一个数组长度len1 &lt; k/2 ,找 总数组k位置的问题，减小为找舍去更小数组所有元素后，第 k - len1 长度的元素  的问题。</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    //solution : 分别查找到k/2处，判断该位置的两个列表元素的大小，舍弃更小的一方，因为在该位置和它以前一定不是中间位置</span><br><span class="line">    //方法本质：分治法</span><br><span class="line">    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        //解决两个数字之和有奇数和偶数的差别</span><br><span class="line">        int len1 = nums1.length;</span><br><span class="line">        int len2 = nums2.length;</span><br><span class="line">        int llen = (len1+len2+1)/2;</span><br><span class="line">        int rlen = (len1+len2+2)/2;</span><br><span class="line">         //如果长度之和是奇数，计算两次同样的值</span><br><span class="line">        return (getKth(nums1,0,len1-1,nums2,0,len2-1,llen) + getKth(nums1,0,len1-1,nums2,0,len2-1,rlen))*0.5;</span><br><span class="line">    &#125;</span><br><span class="line">    //得到第K大的元素</span><br><span class="line">    private double getKth(int[] nums1,int start1,int end1,int[] nums2,int start2,int end2,int k)&#123;</span><br><span class="line">        int len1 = end1 - start1 + 1;</span><br><span class="line">        int len2 = end2 - start2 + 1;</span><br><span class="line">        //交换顺序，保证nums1是最短的，方便判断，放置溢出</span><br><span class="line">        if(len1 &gt; len2) return getKth(nums2,start2,end2,nums1,start1,end1,k);</span><br><span class="line">        if(len1 == 0) return nums2[start2 + k -1];</span><br><span class="line">        if(k == 1) return Math.min(nums1[start1],nums2[start2]);</span><br><span class="line"></span><br><span class="line">        int pos1 = start1 + Math.min(len1,k/2)-1;</span><br><span class="line">        int pos2 = start2 + Math.min(len2,k/2)-1;</span><br><span class="line">        if(nums1[pos1]&lt;=nums2[pos2])&#123;</span><br><span class="line">            return getKth(nums1,pos1+1,end1,nums2,start2,end2,k-(pos1 - start1 +1));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return getKth(nums1,start1,end1,nums2,pos2+1,end2,k-(pos2 - start2 +1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="寻找最长回文子串"><a href="#寻找最长回文子串" class="headerlink" title="寻找最长回文子串"></a>寻找最长回文子串</h2><blockquote><p>思想：</p><ol><li>关键在于回文串长度可能是奇数 也可能是偶数</li><li>将序列划分成 2N-1 个比较点（两字符的间隙也视为开始判断的起点）</li><li>每次都从一个切片点开始扩展，遇到不满足回文的子序列时，下次就从该位置开始判断。</li><li>时间复杂度为O（n）</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">       if(s.length()&lt;=1) return s;</span><br><span class="line">       int maxLen = 0;</span><br><span class="line">       int posStart = 0;</span><br><span class="line"></span><br><span class="line">       for(int i = 0 ;i &lt; s.length(); i++)&#123;</span><br><span class="line">           int len1 = centerExpand(s,i,i);</span><br><span class="line">           int len2 = centerExpand(s,i,i+1);</span><br><span class="line">           if(maxLen &lt; Math.max(len1,len2))&#123;</span><br><span class="line">               maxLen = Math.max(len1,len2);</span><br><span class="line">               if(maxLen%2 != 0) posStart = i - maxLen/2;</span><br><span class="line">               else posStart = i - (maxLen - 1)/2;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return s.substring(posStart,posStart+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    private int centerExpand(String s,int left,int right)&#123;</span><br><span class="line">        while(left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left --;</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return right - left -1 ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Z-变换"><a href="#Z-变换" class="headerlink" title="Z 变换"></a>Z 变换</h2><blockquote><p>题干：</p><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><p>L   C   I   R<br>E T O E S I I G<br>E   D   H   N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>来源：力扣（LeetCode）</p></blockquote><blockquote><p>关键：</p><ol><li>要找到 Z 字字符放置位置的关系</li><li>总间隔为gap = N+N-2</li><li>每一行，一个Z的字符间隙之和都是gap，gap1=gap-2i，gap2=2i，gap2</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String convert(String s, int numRows) &#123;</span><br><span class="line">        if(numRows == 1) return s;</span><br><span class="line">        StringBuffer strbuff = new StringBuffer(&quot;&quot;);</span><br><span class="line">        int gap = numRows + numRows -2 ;</span><br><span class="line">        for(int i =0; i &lt; numRows; i++)&#123;</span><br><span class="line">            int[] dist = new int[2];</span><br><span class="line">            dist[1] = gap - 2*i;</span><br><span class="line">            dist[0] = 2*i;</span><br><span class="line">            if(i==0 || i== numRows-1)&#123;</span><br><span class="line">                dist[0] = gap;</span><br><span class="line">                dist[1] = gap;</span><br><span class="line">            &#125;</span><br><span class="line">            int num = 0;//表示奇偶次数</span><br><span class="line">            for(int j = i; j &lt; s.length(); j+=dist[num%2])&#123;</span><br><span class="line">                strbuff.append(s.charAt(j));</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return strbuff.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="水池问题"><a href="#水池问题" class="headerlink" title="水池问题"></a>水池问题</h2><blockquote><p>题干：</p><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p>来源：力扣（LeetCode）</p><p>思想——典型的动态规划</p><p>随着宽度减小，只有高度更小的柱体高度变高才会有可能让体积变大</p></blockquote><p><img src="https://ae01.alicdn.com/kf/U1040bc26e5a8422ea93aba8fd8c752c83.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public int maxArea(int[] height) &#123;</span><br><span class="line">        int len = height.length;</span><br><span class="line">        int maxC = 0;</span><br><span class="line">        int left = 0, right = height.length -1;</span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            maxC = Math.max(maxC , (right - left)*Math.min(height[left] , height[right]));</span><br><span class="line">            if(height[right]&gt;=height[left])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return maxC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><blockquote><p>题干：</p><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><p>来源：力扣（LeetCode）</p><p>思想：降维，让三维变为二维</p><p>排序<br>确定一个数（非负数）让另外连个比它大的数之和等于它的相反数（避免重复）<br>三数之和最接近问题：就是三数之和变体，多记录一个差值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        //先将数组排序</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        //找到正负交界</span><br><span class="line">        int splitDis =0;</span><br><span class="line">        while(splitDis&lt;nums.length &amp;&amp; nums[splitDis++]&lt;=0);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;();</span><br><span class="line">        //选择一个当作标准</span><br><span class="line">        for(int i = 0;i&lt;Math.min(splitDis-1, nums.length-2);i++)&#123;</span><br><span class="line">            //避免重复</span><br><span class="line">            if(i==0 ||i&gt;0 &amp;&amp; nums[i] !=nums[i-1])&#123;</span><br><span class="line">                int low = i + 1,high = nums.length - 1,sum  = -1*nums[i];</span><br><span class="line">                while(low &lt; high)&#123;</span><br><span class="line">                    if((nums[low]+nums[high])==sum)&#123;</span><br><span class="line">                        ls.add(Arrays.asList(nums[i],nums[low],nums[high]));</span><br><span class="line">                        while(low&lt;high &amp;&amp; nums[low] == nums[low+1]) low++;</span><br><span class="line">                        while(low&lt;high &amp;&amp; nums[high] == nums[high-1]) high--;</span><br><span class="line">                        low++;</span><br><span class="line">                        high--;</span><br><span class="line">                    &#125;else if((nums[low]+nums[high])&lt; sum)&#123;</span><br><span class="line">                        while(low&lt;high &amp;&amp; nums[low]==nums[low+1]) low++;</span><br><span class="line">                        low++;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        while(low&lt;high &amp;&amp; nums[high] == nums[high-1]) high--;</span><br><span class="line">                        high--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="删除链表倒数第n个节点"><a href="#删除链表倒数第n个节点" class="headerlink" title="删除链表倒数第n个节点"></a>删除链表倒数第n个节点</h2><blockquote><p>题干：</p><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><p>来源：力扣（LeetCode）</p><p>思想</p><p>遍历一遍，增加一个记录gap的量，当未达到n删除指针不动,gap加一<br>gap等于n时候，删除指针也不断移动，gap不变。<br>到最后，用删除指针删除节点</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一遍扫描</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">        ListNode general = head;</span><br><span class="line">        ListNode soldier = head;</span><br><span class="line">        <span class="comment">//找到 倒数n+1 个节点</span></span><br><span class="line">        <span class="keyword">while</span>(soldier.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gap &lt; n)&#123;</span><br><span class="line">                gap++;</span><br><span class="line">                soldier = soldier.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                soldier =soldier.next;</span><br><span class="line">                general = general.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(gap == n-<span class="number">1</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            general.next = general.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><blockquote><p>模式匹配的一种<br>包含多种题型<br>本质都是动态规划或者加上栈的运用</p></blockquote><h4 id="有效括号匹配"><a href="#有效括号匹配" class="headerlink" title="有效括号匹配"></a>有效括号匹配</h4><blockquote><p>问题：</p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(p);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span>|| c==<span class="string">'&#123;'</span> || c ==<span class="string">'['</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">char</span> b = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(!isMatch(b,c))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> a , <span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">if</span>(b==<span class="string">')'</span>) flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">                <span class="keyword">if</span>(b==<span class="string">'&#125;'</span>) flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">                <span class="keyword">if</span>(b ==<span class="string">']'</span>) flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="括号的生成"><a href="#括号的生成" class="headerlink" title="括号的生成"></a>括号的生成</h4><blockquote><p>本质：DFS </p><p>题目：</p><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; lstr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//用len来代替栈的功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//本质是找出出栈的所有组合,用DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> lstr;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">        DFS(str,n,n);</span><br><span class="line">        <span class="keyword">return</span> lstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//left = 剩下左括号的数目，right = 剩下右括号多少</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(StringBuffer strBuff,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            lstr.add(strBuff.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">            len++;</span><br><span class="line">            strBuff.append(<span class="string">"("</span>);</span><br><span class="line">            DFS(strBuff,left -<span class="number">1</span>,right);</span><br><span class="line">            strBuff.deleteCharAt(strBuff.length()-<span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            len--;</span><br><span class="line">            strBuff.append(<span class="string">")"</span>);</span><br><span class="line">            DFS (strBuff,left,right -<span class="number">1</span>);</span><br><span class="line">            strBuff.deleteCharAt(strBuff.length()-<span class="number">1</span>);</span><br><span class="line">           len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h4><blockquote><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:</p><p>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类似于KMP模式匹配的next数组的构建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span> p = -<span class="number">1</span> ,left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">                next[i] = p ;</span><br><span class="line">                p = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                next[i] = i;</span><br><span class="line">                <span class="keyword">if</span>(left == <span class="number">0</span>)&#123;</span><br><span class="line">                    p = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    maxNum = Math.max(maxNum,i - next[p]);</span><br><span class="line">                    p = next[p];</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="合并K个有序链表"><a href="#合并K个有序链表" class="headerlink" title="合并K个有序链表"></a>合并K个有序链表</h2><blockquote><p>题目：</p><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><p>输入:<br>[<br> 1-&gt;4-&gt;5,<br> 1-&gt;3-&gt;4,<br> 2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类似于2路归并排序,时间超出限制</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public ListNode mergeKLists(ListNode[] lists) &#123;</span></span><br><span class="line"><span class="comment">        int len = lists.length;</span></span><br><span class="line"><span class="comment">        while(len &gt; 1)&#123;</span></span><br><span class="line"><span class="comment">            int p = 0;</span></span><br><span class="line"><span class="comment">            for(int i = 0;i+1&lt; len ;i+=2)&#123;</span></span><br><span class="line"><span class="comment">                lists[p] = mergeTwo(lists[i],lists[i+1]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            len = (len + 1)/2 ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return lists[0];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public ListNode mergeTwo(ListNode l1,ListNode l2)&#123;</span></span><br><span class="line"><span class="comment">            ListNode root = new ListNode(-1);</span></span><br><span class="line"><span class="comment">            ListNode worker = root;</span></span><br><span class="line"><span class="comment">            while(l1!=null &amp;&amp; l2 != null)&#123;</span></span><br><span class="line"><span class="comment">                if(l1.val &lt;= l2.val)&#123;</span></span><br><span class="line"><span class="comment">                    worker.next = l1;</span></span><br><span class="line"><span class="comment">                    l1 = l1.next;</span></span><br><span class="line"><span class="comment">                &#125;else&#123;</span></span><br><span class="line"><span class="comment">                    worker.next = l2;</span></span><br><span class="line"><span class="comment">                    l2 = l2.next;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                worker = worker.next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(l1 != null) worker.next = l1;</span></span><br><span class="line"><span class="comment">            if(l2 !=null) worker.next = l2;</span></span><br><span class="line"><span class="comment">            return root.next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> mergeAll(lists);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//时间复杂度为n的算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeAll</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lists.length;</span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode worker = root;</span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[cursor] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                lists[cursor] = lists[--len];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cursor++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> key = findMin(lists,len);</span><br><span class="line">            worker.next = lists[key];</span><br><span class="line">            worker = worker.next;</span><br><span class="line">            lists[key] = lists[key].next;</span><br><span class="line">            <span class="keyword">if</span>(lists[key] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode tmp = lists[key];</span><br><span class="line">                lists[key] = lists[len-<span class="number">1</span>];</span><br><span class="line">                lists[len-<span class="number">1</span>] = tmp;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        worker.next = lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minKey = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minVal = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt; len ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i].val &lt; minVal)&#123;</span><br><span class="line">                minKey = i;</span><br><span class="line">                minVal = lists[i].val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="交换链表的节点"><a href="#交换链表的节点" class="headerlink" title="交换链表的节点"></a>交换链表的节点</h2><blockquote><p>利用O（N）的时间完成任务</p></blockquote><h4 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h4><blockquote><p>题干:</p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        root.next = head;</span><br><span class="line">        ListNode left = root, right = head;</span><br><span class="line">        <span class="keyword">while</span>(right!= <span class="keyword">null</span> &amp;&amp; right.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            right= right.next;</span><br><span class="line">            left.next.next = right.next;</span><br><span class="line">            right.next = left.next;</span><br><span class="line">            left.next = right;</span><br><span class="line">            left = right.next;</span><br><span class="line">            right = left.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="K-组一个翻转"><a href="#K-组一个翻转" class="headerlink" title="K 组一个翻转"></a>K 组一个翻转</h4><blockquote><p>题干：</p><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例 :</p><p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>说明 :</p><p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>),post , pre = root;</span><br><span class="line">        root.next = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = root.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length/k;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; k-<span class="number">1</span> ;j++)&#123; </span><br><span class="line">                post = head.next;</span><br><span class="line">                head.next = post.next;</span><br><span class="line">                post.next = pre.next;</span><br><span class="line">                pre.next = post;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="实现子串的查找"><a href="#实现子串的查找" class="headerlink" title="实现子串的查找"></a>实现子串的查找</h2><blockquote><p>题干：</p><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p>示例 1:</p><p>输入: haystack = “hello”, needle = “ll”<br>输出: 2<br>示例 2:</p><p>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1<br>说明:</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> KMPMatch(haystack,needle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KMPMatch</span><span class="params">(String haystack, String needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(needle);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;  <span class="comment">//记录字串待匹配的配置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;haystack.length();i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(p!=<span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(p))&#123;</span><br><span class="line">                    p = next[p -<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(p))&#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">           <span class="keyword">if</span>(p == needle.length())   <span class="keyword">return</span> i - p + <span class="number">1</span> ;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String needle)&#123;</span><br><span class="line">        <span class="keyword">int</span> [] next = <span class="keyword">new</span> <span class="keyword">int</span>[needle.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;            <span class="comment">//首字母匹配长度一定为0</span></span><br><span class="line">        <span class="keyword">int</span> record = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt; needle.length();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(record !=<span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(record))&#123;</span><br><span class="line">                record = next[record -<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i) == needle.charAt(record))&#123;</span><br><span class="line">                record++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = record ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><blockquote><p>题干：</p><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = nums.length -<span class="number">2</span>;p&gt;=<span class="number">0</span>;p--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p]&lt;nums[p+<span class="number">1</span>])&#123;</span><br><span class="line">                reverse(nums,p+<span class="number">1</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[p],i=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(;p+i &lt; nums.length &amp;&amp; nums[p+i] &lt;= nums[p] ;i++) ;</span><br><span class="line">                nums[p] = nums[p + i];</span><br><span class="line">                nums[p+i] = tmp;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="查找元素在排序数组中的开始位置和结束位置"><a href="#查找元素在排序数组中的开始位置和结束位置" class="headerlink" title="查找元素在排序数组中的开始位置和结束位置"></a>查找元素在排序数组中的开始位置和结束位置</h2><blockquote><p>题干：</p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>来源：力扣（LeetCode）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pos = &#123;Integer.MAX_VALUE,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先找开始位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                pos[<span class="number">0</span>] = mid;</span><br><span class="line">                high = mid -<span class="number">1</span>; <span class="comment">//继续缩小左端点范围</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                high = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos[<span class="number">0</span>] == Integer.MAX_VALUE)&#123;</span><br><span class="line">            pos[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line">        high = nums.length -<span class="number">1</span>;</span><br><span class="line">        low = pos[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">        pos[<span class="number">1</span>] = pos[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//找结束位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                pos[<span class="number">1</span>] = mid;</span><br><span class="line">                low = mid +<span class="number">1</span>; <span class="comment">//继续缩小右端点范围</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                low = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="数独问题"><a href="#数独问题" class="headerlink" title="数独问题"></a>数独问题</h2><h4 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h4><blockquote><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p>来源：力扣（LeetCode）</p></blockquote><p><img src="https://ae01.alicdn.com/kf/Uee6c9f587ebc4a75bb02e89c2f51ea8fL.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立3 个 set[9] 分别放入每一行，列，3*3中出现的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        Set[] row = <span class="keyword">new</span> HashSet[board.length];</span><br><span class="line">        Set[] colum = <span class="keyword">new</span> HashSet[board.length];</span><br><span class="line">        Set[] minBoard = <span class="keyword">new</span> HashSet[board.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            row[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            colum[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            minBoard[i] = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;board.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!row[i].add(board[i][j])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!colum[j].add(board[i][j])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!minBoard[(i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span>].add(board[i][j])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;寻找两个有序数组的中位数&lt;br&gt;寻找最长回文子串&lt;br&gt;Z变换&lt;br&gt;水池问题&lt;br&gt;三数之和&lt;br&gt;删除链表倒数第n个节点&lt;br&gt;括号匹配问题&lt;br&gt;交换链表的节点&lt;br&gt;查找元素在排序数组中的开始位置和结束位置&lt;br&gt;实现子串的查找&lt;br&gt;下一个排列&lt;br&gt;数独问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.arkxkz.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://www.arkxkz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>基本的排序算法</title>
    <link href="https://www.arkxkz.com/2019/08/18/%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://www.arkxkz.com/2019/08/18/基本的排序算法/</id>
    <published>2019-08-18T13:18:43.000Z</published>
    <updated>2019-08-18T13:23:54.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本排序方法概念介绍</p><p>插入排序、交换排序、选择排序，归并排序，基数排序，外部排序</p><p>基本实现</p></blockquote><a id="more"></a><h1 id="基本知识框架"><a href="#基本知识框架" class="headerlink" title="基本知识框架"></a>基本知识框架</h1><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><ul><li>插入排序</li><li>交换排序</li><li>选择排序</li><li>归并排序</li><li>基数排序</li></ul><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><ul><li>多路归并排序</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、定义</p><p>​     排序：输入n个值，输出值按照一定规律（递增或者递减）排列</p><p>2、稳定性</p><p>​    在排序后，如果两个key值相同的元素，它们的相对位置没有改变，就是稳定的排序算法，否则，不稳定。</p><p>3、内外部排序</p><p>​    内部排序——全部数据同时存放在内存中的排序交内部排序。</p><p>​    外部排序——排序期间的元素，无法同时存储在内存中的排序</p><p>4、时间复杂度和空间复杂度</p><p>​    不同的算法有不同的时间复杂度</p><p>​    同一个算法，不同的情况时间复杂度可能不同（平均时间复杂度，最好时间复杂度）</p><hr><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><blockquote><p>本质；就是将未排好序的元素，插入到排好序元素列中。</p><p>类别：直接插入，折半插入，希尔排序</p></blockquote><h2 id="直接插入法"><a href="#直接插入法" class="headerlink" title="直接插入法"></a>直接插入法</h2><p>概念：根据它叫法，可大致判断该排序方法</p><p>算法：</p><ul><li>查找出L[i]元素的位置k</li><li>将L[]中k~（i-1 ）的元素后移一位</li><li>将i元素插入到L[k]中</li></ul><p>程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSortDirect</span><span class="params">(ElemType an[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        an[<span class="number">0</span>] = an[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>;i&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(an[<span class="number">0</span>]&lt;an[j])&#123;</span><br><span class="line">                an[j+<span class="number">1</span>]=an[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        an[j+<span class="number">1</span>] = an[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ElemType an[]=&#123;<span class="number">-1</span>,<span class="number">23</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">87</span>,<span class="number">54</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">67</span>,<span class="number">68</span>,<span class="number">25</span>,<span class="number">35</span>,<span class="number">39</span>,<span class="number">17</span>,<span class="number">14</span>,<span class="number">48</span>,<span class="number">61</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">28</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    insertSortDirect(an,<span class="number">21</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">21</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;an[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度O（1）</p><p>时间复杂度O(n^2)</p><p>最好情况——已经排好序，比较次数n次</p><p>最差情况——逆序，比较次数i从2到n求和</p><p>稳定性：稳定</p><p>适用：顺序存储结构和链式存储结构（可以从前往后查找）</p><hr><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><blockquote><p>将折半查找与运用与直接插入的查找中</p></blockquote><p>与直接插入最大区别：在查找位置时候，使用折半查找法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSortBinary</span><span class="params">(ElemType an[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        an[<span class="number">0</span>] = an[i];</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>,tail=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (head+tail)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(an[mid]&gt;an[<span class="number">0</span>])&#123;<span class="comment">//保证稳定,所以不取等号</span></span><br><span class="line">                tail = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=tail+<span class="number">1</span>;j--)&#123;</span><br><span class="line">            an[j+<span class="number">1</span>] = an[j];</span><br><span class="line">        &#125;</span><br><span class="line">        an[tail+<span class="number">1</span>] = an[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><p>比较次数与元素的初始排列无关，仅仅取决于n</p><p>比较次数 n*log(2,n)</p><p>时间复杂度O（n^2)</p><p>稳定性：稳定</p><p>适用：顺序存储结构（因为折半查找）</p><hr><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>缩小增量排序</p></blockquote><p>基本思想：</p><p>在直接插入排序的基础上，知道，当待排序列有序程度越高，耗费时间复杂度越低。将待排序列表分为多个待排子表L[i,i+d,i+2d,……]，当“基本有序”时候，进行一次直接插入排序。</p><p>基本过程：</p><ul><li>先去一个小于n的步长d1，将L【】分为n/d1 组，对每组进行组内排序。（组内排序随便）</li><li>上一步步完成，取小于di，的步长di+1，同样进行组内排序。</li><li>循环第二步，知道d=1完成</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步长d1=len/2，di=di-1/2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(ElemType an[] ,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d = len/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d+<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            an[<span class="number">0</span>] = an[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i-d;j&gt;<span class="number">0</span>&amp;&amp;an[j]&gt;an[<span class="number">0</span>];j-=d)&#123;</span><br><span class="line">                an[j+d]=an[j];</span><br><span class="line">            &#125;</span><br><span class="line">            an[j+d]=an[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>空间复杂度：O(1)</p><p>时间复杂度：特定范围内 O（n^1.3）。最坏情况 O(n^2)</p><p>稳定性：<strong>不稳定</strong>，原因在于 步长不等于一时候，可能出现“<strong>跨值</strong>”插入（与直接插入最大不同就是不是一个一个顺序比较后进顺序插入，而是以dk为距离进行插入，在dk距离上，可能出现key值相同的元素）。</p><p>适用：<strong><em>顺序存储结构</em></strong>的序列</p><hr><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><blockquote><p>概念：根据叫法得知，直接与要置放带交换元素位置中的元素交换位置</p><p>类别：冒泡排序和快速排序</p></blockquote><p>区别与插入排序最大不同：直接交换，不需要在进行大量元素的移位</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>概念：每一次”遍历“得到一个未排序序列中的最值，称为一次”冒泡“。</p><p>基本思想：进行n-1次“冒泡”，得到了最终的结果。每次冒泡的值，放在序列末尾。</p><p>提高效率：如果一次冒泡中，没有发生元素的交换，说明顺序已经排列完成，可以不用就绪“冒泡”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(ElemType an[] ,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;<span class="comment">//一共进行n-1次冒泡</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//判断这次冒泡，是否交换位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(an[j]&gt;an[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = an[j];</span><br><span class="line">                an[j]=an[j+<span class="number">1</span>];</span><br><span class="line">                an[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>)&#123;<span class="comment">//为交换位置，退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O（1）</p><p>时间复杂度：最好O（n），最差和平均O(n^2)</p><p>稳定性：稳定（未发生跨值比较，都是按顺序比较）</p><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>概念：对冒泡排序的改进，将移动的次数减少（冒泡每次都要总开始，或者末尾进行遍历）</p><p>算法思想：</p><ul><li>分治法：选取一个元素作为“哨兵”，将待排序的序列分成了两组，一组全部小于该“哨兵”，另一组全部大于，可以类比<strong>二叉树</strong>，左子树全部小于父节点，右子树全部大于父节点。</li><li>递归对两个子表进行同样的过程，知道每部分只有一个元素，或者为空。</li><li>每次都能将一个元素，放到它该在的位置（同冒泡一样）。</li></ul><p>特点：</p><ul><li>哨兵的选择很重要，尽可能的选择“靠中”的元素作为“哨兵”</li><li>在待排序的元素很大时，才体现了它的优越性，在待排序序列中，元素很少时候，用简单的方法往往更有效。</li></ul><p><strong>算法中的理解：</strong></p><p>​    哨兵位置，决定了开始的“头”（partionlIst中第一次判断是从high开始还是从low开始），如果将List[low]作为pivot，则从high开始判断，第一个交换元素，必须是high——&gt;low；反之，从low开始。</p><p>​    原因：采用直接List[low]作为pivot（或者通过操作将pivot的值交换到low位置）的方法，保证不需要进行swap，直接进行赋值，因为恰好List[low]被pivot复制一次，腾出了“空位”。如果我们从low端开始，当遇到了第一个大于pivot的值，使用swap（low，high）交换，此时只能保证交换到high位置的值是大于pivot的，不能保证交换到low的值一个是小于pivot的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快排的划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partionList</span><span class="params">(ElemType an[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最简单的哨兵选择,缺点在于可能导致不“平衡”</span></span><br><span class="line">    <span class="comment">//ElemType pivot = an[low];</span></span><br><span class="line">    <span class="comment">//对“哨兵”的选择，选择前三个元素中中间值</span></span><br><span class="line">    ElemType pivot;</span><br><span class="line">    <span class="keyword">int</span> middle =low;</span><br><span class="line">    <span class="keyword">if</span>((high-low)&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> small,large;</span><br><span class="line">        small = an[low]&lt;an[low+<span class="number">1</span>]?low:low+<span class="number">1</span>;</span><br><span class="line">        small = an[small]&lt;an[low+<span class="number">2</span>]?small:low+<span class="number">2</span>;</span><br><span class="line">        large = an[low]&gt;an[low+<span class="number">1</span>]?low:low+<span class="number">1</span>;</span><br><span class="line">        large = an[large]&gt;an[low+<span class="number">2</span>]?large:low+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>&amp;&amp;(middle==small ||middle==large);i++,middle++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将哨兵替换到low位置，方便交换</span></span><br><span class="line">    ElemType tmp = an[low];</span><br><span class="line">    an[low] = an[middle];</span><br><span class="line">    an[middle] = tmp;</span><br><span class="line">    pivot = an[low];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;an[high]&gt;=pivot)&#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        an[low]=an[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;an[low]&lt;=pivot)&#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        an[high]=an[low];</span><br><span class="line">    &#125;</span><br><span class="line">    an[low]= pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(ElemType an[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = partionList(an,low,high);</span><br><span class="line">        quickSort(an,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        quickSort(an,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析——想象一棵<strong>二叉树</strong></p><p>空间复杂度：调用了栈，空间复杂度相当于二叉树的高，O(log(2,n))</p><p>时间复杂度：所有内部排序中平均复杂度最优的排序算法，O(n*log(2,n))</p><p>稳定性： 不稳定(很显然)</p><hr><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote><p>概念：根据此次”次序“的要求，从队列中选择出核实的元素，放到该位置。</p><p>类别：基本选择排序，堆排</p></blockquote><h2 id="基本选择排序"><a href="#基本选择排序" class="headerlink" title="基本选择排序"></a>基本选择排序</h2><p>概念：——从名称就可以看出来</p><p><strong>区别插入排序</strong>：目标（主体不同），插入排序主体是该<strong>元素</strong>，而不是该位置（将元素放到它应该的位置）；选择排序 目标是<strong>位置</strong>，在位置上放入恰当的元素。</p><p>算法思想：~一般人第一次接触排序的思想（反正曾经我是这样）：第一遍，得到最大，第二遍得到第二大。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(ElemType an[] , <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> mini = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;=len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(an[j] &lt; an[mini])&#123;</span><br><span class="line">                mini = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mini!=i)&#123;</span><br><span class="line">            ElemType tmp = an[i];</span><br><span class="line">            an[i] = an[mini];</span><br><span class="line">            an[mini]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度O(1)</p><p>时间复杂度：O（n^2）</p><p>稳定性：不稳定（因为：”跨值“交换），可能在交换的时候，将排在前面的“兄弟”提前交换到后面。</p><hr><h2 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h2><p>概念：一种<strong>树形</strong>的排序方法，利用树的父节点，与子树的关系，构建一颗树，利用树的性质，完成排序任务。</p><p><strong>特点</strong>：</p><ul><li>是一棵<strong>完全二叉树</strong>，将List[]视为完全二叉树的顺序存储结构。</li><li>父节点的大于或者小于所有子树的值</li><li>满足完全二叉树在顺序存储结构中的所有性质。</li></ul><p>堆：</p><ul><li>类别：小根堆（父节点小），大根堆（父节点大）</li><li>L[i]&lt;=L[2i] &amp;&amp; L[i]&lt;L[2i+1]   （小根堆）。大根堆相反</li></ul><p><strong>关键：</strong></p><ul><li>根据L[]，建立一棵满足条件的完全二叉树</li></ul><p>算法思想：（建立完全二叉树）</p><ul><li>“逆节点“进行调整顺序，满足L[i]&gt;L[2i] , L[i]&gt;L[2i+1]（或者是小于），由完全二叉树的性质，开始节点是n/2向下取整（最后一个非叶节点）</li><li>每次到一个分支节点，调整以它为根节点的树的顺序（以大根堆为例）</li><li>如果它子节点中有比它更大的节点，则交换数值，继续调整交换后该节点的子树（可能破坏交换后子节点的双亲节点与子节点的大小关系）</li></ul><p>注意：</p><ul><li>是在原来的List[]结构合空间上，产生一个顺序存储的二叉树，不是使用完全二叉树的插入方法，重新构建一个存储结构和空间。</li><li>当子节点与双亲节点交换后，只可能对交换子节点的条子树产生影响，而不会对双亲节点的另外一个子树产生影响。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点的向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(ElemType an[],<span class="keyword">int</span> pos,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//暂存调整的根节点，减少交换次数</span></span><br><span class="line">    an[<span class="number">0</span>] = an[pos];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*pos;i&lt;=len;i*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i+<span class="number">1</span>)&lt;=len &amp;&amp; an[i+<span class="number">1</span>]&gt;an[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(an[i]&gt;an[i/<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="comment">//避免交换，减少操作次数</span></span><br><span class="line">            <span class="comment">//ElemType tmp = an[i/2];</span></span><br><span class="line">            <span class="comment">//an[i/2] = an[i];</span></span><br><span class="line">            <span class="comment">//an[i]=tmp;</span></span><br><span class="line"></span><br><span class="line">            an[pos] = an[i];</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//避免交换次数过多，在叶节点赋值</span></span><br><span class="line">    an[pos] = an[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建大根子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(ElemType an[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//节点从 n/2 到 1 进行向下调整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        adjustDown(an,i,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(ElemType an[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    buildMaxHeap(an,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        ElemType tmp = an[<span class="number">1</span>];</span><br><span class="line">        an[<span class="number">1</span>]= an[i];</span><br><span class="line">        an[i]=tmp;</span><br><span class="line">        adjustDown(an,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O（1）</p><p>时间复杂度：O（nlog(2,n)），建立大堆为O（n）</p><p>稳定性：不稳定</p><hr><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote><p>本质：将有序的多个子List[]合并成一个有序的List[]</p><p>分类：2路归并，多路归并</p></blockquote><p>与希尔排序区分：归并排序后，将子集合并；希尔排序后，产生更多的“子集”（d变小）。</p><p>算法思想：（二路归并）</p><ul><li>最先将list视为n个长度d为1的子集组成的集合体，每个子集合都是有序的。</li><li>两两归并，合并成n/2个d=d*2 大小的新有序集。</li><li>递归，知道d=n</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeLists</span><span class="params">(ElemType an[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bn[<span class="number">50</span>];<span class="comment">//随便设置一个大于等于an的顺序存储容器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = low;i&lt;=high;i++)&#123;</span><br><span class="line">        bn[i]=an[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pointLow,pointHigh,i;</span><br><span class="line">    <span class="keyword">for</span>(pointLow=low, pointHigh=mid+<span class="number">1</span>, i = low;pointLow&lt;=mid&amp;&amp;pointHigh&lt;=high&amp;&amp; i&lt;=high;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bn[pointLow]&lt;=bn[pointHigh])&#123;</span><br><span class="line">            an[i] = bn[pointLow++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            an[i]= bn[pointHigh++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pointLow&lt;=mid)&#123;</span><br><span class="line">        an[i++]=bn[pointLow++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pointHigh&lt;=high)&#123;</span><br><span class="line">        an[i++]=bn[pointHigh++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二路归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(ElemType an[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(an,low,mid);</span><br><span class="line">        mergeSort(an,mid+<span class="number">1</span>,high);</span><br><span class="line">        mergeLists(an,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O（N）</p><p>时间复杂度：O（n*log（2，n）），每次归并：O（n）</p><p><strong>稳定性</strong> ：稳定</p><hr><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><blockquote><p>概念：不基于比较进行排序，而是基于分类 与 收集 进行排序</p></blockquote><p>概念：各个关键字进行大小比较，利用<strong>稳定性</strong>，进行分配与收集，最终得到正确的排序顺序。</p><p>关键：<strong>稳定性</strong></p><p>算法思想：</p><ul><li>分配：通过不同的关键字，将元素放入不同的<strong>队列</strong>中——保证稳定（先入先出）</li><li>收集：按照属性值（队列）的优先级，进行出队列，放回到原来list[]中。</li></ul><p>注意：要从影响小的属性开始分配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baseSort</span><span class="params">(ElemType an[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;ElemType&gt; qn[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        ElemType bn[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=len;k++)&#123;</span><br><span class="line">            bn[k]=an[k]/tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> flag = bn[j]%<span class="number">10</span>;</span><br><span class="line">            qn[flag].push(an[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//收集</span></span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">9</span>,point=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!qn[h].empty())&#123;</span><br><span class="line">                an[point++]=qn[h].front();</span><br><span class="line">                qn[h].pop();</span><br><span class="line">            &#125;</span><br><span class="line">            h--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="外部排序-1"><a href="#外部排序-1" class="headerlink" title="外部排序"></a>外部排序</h1><blockquote><p>概念：无法将整个问价复制到内存中进行排序的方法（对比内部排序）</p><p>方法：归并法</p></blockquote><p>主要的方法有：<br></p><ul><li>多路平衡归并与败者树</li><li>置换——选择排序（生成初始归并段）</li><li>最佳归并树</li></ul><hr><blockquote><p>简答实现了一些基本的内部排序，仍然有可以优化的地方</p><p>关于外部排序，还不是很清楚，不易测试，这里只是简答列出来</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本排序方法概念介绍&lt;/p&gt;
&lt;p&gt;插入排序、交换排序、选择排序，归并排序，基数排序，外部排序&lt;/p&gt;
&lt;p&gt;基本实现&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.arkxkz.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.arkxkz.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>查找的基本数据结构概括一</title>
    <link href="https://www.arkxkz.com/2019/08/11/%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E6%8B%AC%E4%B8%80/"/>
    <id>https://www.arkxkz.com/2019/08/11/查找的基本数据结构概括一/</id>
    <published>2019-08-11T03:09:41.000Z</published>
    <updated>2019-08-11T03:16:03.715Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍查找的基本数据结构（一）</p><p>线形结构：顺序查找，折半查找，分块查找</p><p>树形结构：B树，B+ 树</p></blockquote><a id="more"></a><h2 id="查找的基本数据结构概括"><a href="#查找的基本数据结构概括" class="headerlink" title="查找的基本数据结构概括"></a>查找的基本数据结构概括</h2><h3 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h3><ul><li>静态查找：不涉及增删的查找</li><li>动态查找：设计增删修改的查找</li></ul><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><ul><li>顺序查找</li><li>折半查找</li><li>分块查找</li></ul><h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><ul><li>二分排序树</li><li>二分平衡树</li><li>B树</li><li>B+ 树</li></ul><h3 id="散列结构"><a href="#散列结构" class="headerlink" title="散列结构"></a>散列结构</h3><ul><li>散列表</li></ul><hr><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><blockquote><p>一般线性表的顺序查找</p><p>有序表的顺序查找</p></blockquote><h4 id="一般线性表的顺序查找"><a href="#一般线性表的顺序查找" class="headerlink" title="一般线性表的顺序查找"></a>一般线性表的顺序查找</h4><p>概念：遍历一遍，查看是否有相同的元素。</p><p>特点：</p><ul><li>表可以无序</li><li>哨兵——0号地址单元，避免不必要的判断条件</li><li>查找成功的平均查找长度——（n+1）/2</li><li>查找失败的长度—— n+1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SSTable</span>&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> TableLength;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化构造输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSSTable</span><span class="params">(SSTable &amp;stable)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> an[] =&#123;<span class="number">-1</span>,<span class="number">21</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">78</span>,<span class="number">4</span>,<span class="number">30</span>,<span class="number">28</span>,<span class="number">98</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">18</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    stable.elem = an;</span><br><span class="line">    stable.TableLength = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一般线性表的顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchSeq</span><span class="params">(SSTable st, ElemType key)</span></span>&#123;</span><br><span class="line">    st.elem[<span class="number">0</span>] = key;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = st.TableLength ; st.elem[i]!=key; i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SSTable st;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">78</span>;</span><br><span class="line">    initSSTable(st);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; searchSeq(st,key) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序表的顺序查找"><a href="#有序表的顺序查找" class="headerlink" title="有序表的顺序查找"></a>有序表的顺序查找</h4><p>与无序表的区别：</p><ul><li>给出的查找序列必须有序</li><li>可以降低查找失败的平均查找长度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSSTable</span><span class="params">(SSTable &amp;stable)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> an[] =&#123;<span class="number">-1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">78</span>,<span class="number">98</span>&#125;;</span><br><span class="line">    stable.elem = an;</span><br><span class="line">    stable.TableLength = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchSeq</span><span class="params">(SSTable st, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt; i&lt;=st.TableLength;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.elem[i]==key)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(st.elem[i]&gt;key)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><blockquote><p>二分查找</p></blockquote><p>基本概念：</p><p>对于有序序列，采用数学上的二分法进行查找。</p><p>本质：</p><ul><li>查找过程相当于根据了一棵<strong>判定树</strong>（二叉树），进行判断</li></ul><p>特点</p><ul><li>仅适用于线性表的<strong>顺序存储结构</strong>，不适用于<strong>链式结构</strong>（因为要随机访问）</li><li>序列必须有序</li><li>查找成功——查找关键值是非叶子结点（非叶子结点代表序列中存在的值）</li><li>查找失败——查找最后到了叶子结点（叶子结点表示失败数的范围）</li><li>查找的长度——到达的深度,最大深度为log(2,n+1)向上取整</li><li>时间复杂度——log(2,n)</li></ul><p>判定树：</p><ul><li>是一棵平衡二叉树，平衡因子的绝对值小于等于1——|左右节点差值|&lt;=1</li><li>判定树的构建，是一个递归过程</li><li><strong>所有子树的构建方式都必须一样——子树的“生长方向”必须一致</strong></li></ul><p>如图：<br></p><p><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5tvpca1snj30jr0bsta3.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span>&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> Length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSeqList</span><span class="params">(SeqList &amp;sq)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> an[]=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">65</span>,<span class="number">67</span>,<span class="number">69</span>,<span class="number">76</span>,<span class="number">77</span>,<span class="number">80</span>,<span class="number">110</span>,<span class="number">131</span>&#125;;</span><br><span class="line">    sq.elem=an;</span><br><span class="line">    sq.Length = <span class="number">14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(SeqList sq,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>,tail = sq.Length <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;=tail)&#123;</span><br><span class="line">        mid = (head+tail)/<span class="number">2</span>;<span class="comment">//也可以向上取整，但是判定树的走势要改变</span></span><br><span class="line">        <span class="keyword">if</span>(sq.elem[mid]== key)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; sq.elem[mid])&#123;</span><br><span class="line">            tail=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; sq.elem[mid])&#123;</span><br><span class="line">            head = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SeqList sq;</span><br><span class="line">    initSeqList(sq);</span><br><span class="line">    ElemType key = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;binarySearch(sq,key)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><blockquote><p>索引顺序查找</p></blockquote><p>基本思想：</p><p>为序列建立一个索引，加快搜索</p><p>要求：</p><p>分块后的序列，块内是无序的，但是块间是有序的</p><p>分块示意图：<br></p><p><img src="https://tva4.sinaimg.cn/large/007DFXDhly1g5tvuob6mrj30il09dwht.jpg" alt></p><p>特点：</p><ul><li>使用了索引加快了查找</li><li>类似于B+ 树的简略版</li><li>s（块内大小），b（索引数目）</li><li>查找个数：(s+1)/2+(b+1)/2——都是用顺序查找；(s+1)/2+log(2,b+1)向上取整——二分查找</li></ul><hr><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><blockquote><p>多路平衡查找树</p></blockquote><p>定义：</p><ul><li><p>非叶根节点至少两棵子树</p></li><li><p>每个节点至少 m/2 向上取整，最多（m） 个节点</p></li><li><p>关键字，最少(m/2向上取整-1)， 最多（m-1）</p></li><li><p>同一节点中的关键字是有序排列的</p></li><li><p>所有叶子结点出现在同一层上</p></li></ul><p>本质：</p><p>balance tree ——一棵平衡树（平衡因子等于0）</p><p>特点：</p><p><strong>绝对平衡树</strong></p><p>实例：<br></p><p><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5uxiry72gj30pq0b9agl.jpg" alt></p><h4 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h4><p>前提：暂时没考虑最后一层</p><p>变量声明：</p><ul><li>n——关键字</li><li>m——B树的阶</li><li>h——高度</li></ul><p><em>最小高度：</em></p><p>每个节点中都包含了最多了关键字数目（m-1）；</p><p>总共的关键字树 &lt; （m-1）*（总共节点数）。</p><p>n&lt; (m-1)*(1+m+m^2+m^3+……+m^(h-1))</p><p><strong><em>h&gt;= log(m,n+1)</em></strong></p><p><em>最大高度：</em></p><p>每个节点中包含了最少的关键字数目（m/2 的向上取整）</p><p>查找不成功的节点有n+1个</p><p><strong><em>h&lt;log(T,(n+1)/2  +1)</em></strong></p><p><strong>注意</strong>：</p><p>这儿讲解高度受关键字个数的影响，受节点数目的影响要另外分析</p><h4 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h4><ul><li>在B树中查找节点</li><li>在节点中查找关键字</li></ul><p>简单——自己模拟过程</p><h4 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h4><ul><li>定位：查找算法找到最底层的非页节点</li><li>插入：将data按照排列顺序插入到节点中</li><li>分裂（可能）：当不满足B树的约束条件（关键字&gt;=m)，将节点分裂</li></ul><p>分裂过程</p><p>如果插入后没有影响，则直接插入最底层节点中</p><p>插入后导致B树的阶+1 达到了m+1，将该节点从中间分开，中间节点变成双亲节点中的关键字</p><p>递归操作，因为可能会影响双亲节点。</p><p>只有当影响传递到了根节点时候，才会导致树的高度+1</p><p>插入过程：<br></p><p><img src="https://tva2.sinaimg.cn/large/007DFXDhly1g5uydkenbpj31xe0u0b29.jpg" alt></p><h4 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h4><p>删除的节点在终端节点：</p><ol><li>直接删除（删除后满足  &gt;  (m / 2)的向上取整</li><li>向兄弟借：兄弟节点有多余的关键字，则双亲下方，兄弟上放</li><li>兄弟不借：兄弟节点也没有多于关键字，则双亲与兄弟合并</li></ol><p>删除节点不再终端节点上：<br></p><p><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5uyfyl384j30u01754qq.jpg" alt></p><h4 id="B树的构造"><a href="#B树的构造" class="headerlink" title="B树的构造"></a>B树的构造</h4><p>一个不断插入的过程</p><hr><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h2><blockquote><p>B 树改版</p></blockquote><p>与B树的区别：</p><p>关键字不再是分割作用，而是索引作用，因此每个非根内部节点的关键字范围： m/2的向上取整~ m。在叶节点中，包含了所有的关键字，且关键字不重复，按大小顺序排列。</p><p>B+树的特点</p><ul><li>树结构变化</li><li>节点的关键字变化</li><li>有两种查找方式（对应两个指针），一个从根节点的查找，一种从关键字最小的节点开始查找。</li></ul><p>B+ 树的实例：<br></p><p><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5vjtoifejj30mr09aq73.jpg" alt></p><hr><blockquote><p>基本查找的数据结构还有 hash查找，字符串的匹配</p><p>具体算法操作，有时间再写</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍查找的基本数据结构（一）&lt;/p&gt;
&lt;p&gt;线形结构：顺序查找，折半查找，分块查找&lt;/p&gt;
&lt;p&gt;树形结构：B树，B+ 树&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.arkxkz.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.arkxkz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>决策树基本介绍1</title>
    <link href="https://www.arkxkz.com/2019/08/03/%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D1/"/>
    <id>https://www.arkxkz.com/2019/08/03/决策树基本介绍1/</id>
    <published>2019-08-03T02:46:53.000Z</published>
    <updated>2019-08-03T02:48:40.643Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>决策树的概念<br>决策树算法的简单了解</p></blockquote><a id="more"></a><h2 id="决策树概念"><a href="#决策树概念" class="headerlink" title="决策树概念"></a>决策树概念</h2><ol><li>决策树是一棵树（可以是二叉树，也可以是非二叉树），非叶子结点存放测试属性值，叶子结点是输出的结果</li><li>决策树帮助我们做出判断（或者得出结果），根据一系列属性的判断，在叶子结点得到我们想要的结果</li><li>决策树的主要不在于使用决策树，而是要构建出一颗合适的决策树</li></ol><p>实例：<br></p><p><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5m8bgq8iwj30jo0hegmm.jpg" alt></p><p>上面对是否能偿还银行贷款是一个典型的决策树：根据判断对象的一些属性（房产、结婚、收入），得出结论 判断对象时候有能力偿还贷款。</p><hr><h2 id="决策树的类别"><a href="#决策树的类别" class="headerlink" title="决策树的类别"></a>决策树的类别</h2><ol><li>分类树： 输出类别。分类树的输出是定性的，比如天气，网页是否为垃圾网页等。常用C4.5，ID3。</li><li>回归树： 输出值。回归树的输出是定量的， 比如根据气候，季节等条件输出水位可能上涨多少。</li></ol><hr><h2 id="决策树的构建过程"><a href="#决策树的构建过程" class="headerlink" title="决策树的构建过程"></a>决策树的构建过程</h2><p><strong>决策树的特征选择</strong></p><p><strong>决策树的生成</strong></p><p><strong>决策树的剪枝</strong></p><h3 id="决策树的特征选择"><a href="#决策树的特征选择" class="headerlink" title="决策树的特征选择"></a>决策树的特征选择</h3><p>本质就是帮助我们做出决策的属性（房款，结婚，月收入。。。），在书面上专业用语——<strong>信息增益（信息增益比）</strong>。</p><p><em>信息增益：</em><br></p><ol><li>输入：训练集 和 特征集</li><li>输出：特征值对于 训练集的信息增益g（D，A）</li></ol><p>（1）计算出训练集的经验熵<br></p><p><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5m9jylp2lj30gs04sdfw.jpg" alt></p><p>（2）计算特征值A 对数据集的经验条件熵</p><p>H(D/A)</p><p>（3）计算信息增益熵</p><p>g(D,A) = H(D) - H(D/A)</p><p>信息增益的缺点：会偏向取值更多的点。改进——信息增益比</p><p>信息增益比：gR(D,A) = g(D,A) / HA (D)</p><h3 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h3><p>本质就是对选择的特征进行定位，哪个是根节点，哪些节点是哪些节点的父节点，根据信息增益进行构建——ID3，根据信息增益比——C4.5 ，越重要的特征，它的信息增益或者信息增益比就越大。构建完成后，就相当于模拟人的判断过程。</p><h3 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h3><p>我们比不是使用所有的数据进行构建决策树，我们根据一部分训练集进行构建，因此会可能出现一些问题。比如这个决策树只适用于这个训练集，而不适用于其他数据集，专业用语——出现<strong>过拟合状态</strong>。  我们将极端的“树枝树叶”剪去。增强泛化能力。<strong>本质：</strong> 第二步（决策树的生成）只达到了一个局部最优化，要通过剪枝达到全局最优化——从当前最好，去实现人生的最优化。</p><p>决策树生成：学习局部的模型</p><p>决策树的剪枝：学习整体的模型</p><hr><h2 id="决策树基本算法"><a href="#决策树基本算法" class="headerlink" title="决策树基本算法"></a>决策树基本算法</h2><blockquote><p>简单介绍算法的基本概念</p><p>主要涉及ID3，C4.5</p></blockquote><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>一个分类决策树算法</p><p>输入：数据集D，特征集A，阈值E</p><p>输出：决策树T</p><p>含义：<br></p><p>阈值：当两次迭代的结果都相近时候，就不用了继续迭代了。阈值控制迭代的次数。</p><p>过程：</p><ol><li>D 中所有的实例都属于同一类，T为单节点，将该类作为该节点的类标记。</li><li>A=空（没有特征集）。选择D中类别最多的类作为该节点的类标记。</li><li>否则，计算 A中的所有特征，对于D 的特征增益，得到最大的特征Ag；</li><li>如果Ag &lt; E ：T为单节点数，因为特征没有足够的划分性。</li><li>否则：对于Ag中的每一个值，将D划分成非空子集，每个自己中最多的类作为标记该子节点的类，由节点和子节点构成树返回。</li><li>迭代，递归生成</li></ol><h3 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h3><p>与ID3 算法的区别：只有计算信息增益比，而不是信息增益。</p><h3 id="分类回归树-CART"><a href="#分类回归树-CART" class="headerlink" title="分类回归树 CART"></a>分类回归树 CART</h3><p>基本概念：CART知识构造一个二叉树，每一步只能有两个分支。</p><p>回归树的生成：最小二乘回归树生成算法。找到最优切分变量j 和最优切分点S（本质就是找到j变量j和s使式子值最小）</p><p>分类树的生成：基于*<em>基尼指数</em>（类似于信息增益）</p><p>分类树的剪枝：<br></p><p>​                        1）形成子树序列</p><p>​                        2）在子树序列中通过交叉验证，选怎最优子树</p><hr><blockquote><p>only介绍一个大概知识框架</p><p>如果能考研成功，再继续学习，将所有模块补全吧</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;决策树的概念&lt;br&gt;决策树算法的简单了解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://www.arkxkz.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://www.arkxkz.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>XML 和 JSON</title>
    <link href="https://www.arkxkz.com/2019/07/25/XML-%E5%92%8C-JSON/"/>
    <id>https://www.arkxkz.com/2019/07/25/XML-和-JSON/</id>
    <published>2019-07-25T10:55:32.000Z</published>
    <updated>2019-07-25T10:56:56.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>xml格式的详解</p><p>json格式的详解</p></blockquote><a id="more"></a><hr><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>一种可扩展标记语言</li><li>类似html，都是以标签的方式书写</li><li>html主要用于传输数据，而不是显示数据</li><li>多用于配置文件，如maven中的配置文件</li></ol><p>XML主要是用于传输和显示数据</p><p>编写完XML文件后，它不会自动做任何的事情，仅仅是将数据包装在标签中存储起来。我们需要自己书写程序来传送，接收和显示这个文档<br></p><p>主要区别与html：<br></p><p><strong>可以自定义标签</strong></p><hr><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong><em>在页面中的动态显示数据</em></strong>。在html中如果要显示动态的数据（不是写死在html中，需要后台支持的数据），将数据存储在XML文档中，显示时候，不需要对HTML和CSS做任何修改</p><p><strong><em>简化共享数据</em></strong>。XML以纯文本的形式来进行存储数据，独立于软件和硬件，便于共享</p><p><strong><em>简化数据传输</em></strong>。XML可以通过不同的不兼容的软件来读取，可以降低不兼容系统间数据传输的复杂性</p><p><strong>应用</strong>：<br></p><p>RSS语言</p><hr><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析：<br></p><h4 id="xml声明"><a href="#xml声明" class="headerlink" title="xml声明"></a>xml声明</h4><p>定义XML的版本，使用的编码</p><p>写在一个标签里&lt; &gt;</p><h4 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">.....</span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>含义：文本档是一个标签</p><h4 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h4><p>含义：（理解）这是Jani写给Tove的的一个便签Remender</p><h4 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h4><p>实例：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"COOKING"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"CHILDREN"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"WEB"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>树形结构：<br></p><p><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5c4ej115bj30hq09cwev.jpg" alt></p><hr><h3 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h3><ol><li>声明：——可选</li><li>标签——在声明之后，必须成对，有开，必须有关，不允许html中的省略写法</li><li>标签大小写敏感</li><li>属性值必须加上引号</li><li>使用实体引用代替标记</li><li>注释写法</li></ol><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标签的写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Message</span>&gt;</span>这是错误的<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>这是正确的<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打开与关闭的顺序必须一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多个属性之间直接用空格隔开--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">元素名</span> 属性名<span class="attr">1</span>=<span class="string">"属性值1"</span> 属性名<span class="attr">2</span>=<span class="string">"属性值2"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实体引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meassage</span>&gt;</span>if num $lt; 1000 then <span class="tag">&lt;/<span class="name">meassage</span>&gt;</span></span><br></pre></td></tr></table></figure><p>五种实体引用：<br></p><p><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5c51ylgm8j30mt09f74f.jpg" alt></p><hr><h3 id="元素与属性"><a href="#元素与属性" class="headerlink" title="元素与属性"></a>元素与属性</h3><h4 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h4><blockquote><p>从标签开始的地方到标签结束的地方</p></blockquote><p>元素命名规则：<br></p><ol><li>可以包含字母，数字，和其它字符</li><li>不能以数字或者字符开始</li><li>不能有空格</li><li>不能以xml开始</li><li>最好和程序中的命名规则保持一致</li></ol><p><strong>可扩展性</strong></p><p>在原有的XML中，增添一些其它的标签，程序不会崩溃</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><blockquote><p>尽可能避免属性</p></blockquote><ol><li>属性不易扩展</li><li>难以阅读和维护</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">date</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">day</span>&gt;</span>10<span class="tag">&lt;/<span class="name">day</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">month</span>&gt;</span>01<span class="tag">&lt;/<span class="name">month</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">year</span>&gt;</span>2008<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><blockquote><p>用于后台与服务器交换数据</p></blockquote><p>。。。不了解</p><hr><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><blockquote><p>Document Object Model </p><p>文档对象模型</p></blockquote><p>解析XML文件，将XML解析成树结构，将每个节点看为一个对象，同时定义了访问和操作文档的方法</p><p><strong>本质</strong>：一个xml解析器，能读懂XML文件里的信息</p><p>实例：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>W3Cschool Internal Note<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>To:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"to"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>From:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"from"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Message:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">if (window.XMLHttpRequest)</span><br><span class="line">  &#123;// code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">  xmlhttp=new XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line">else</span><br><span class="line">  &#123;// code for IE6, IE5</span><br><span class="line">  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");</span><br><span class="line">  &#125;</span><br><span class="line">xmlhttp.open("GET","note.xml",false);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlDoc=xmlhttp.responseXML;</span><br><span class="line"></span><br><span class="line">document.getElementById("to").innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName("to")[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById("from").innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName("from")[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById("message").innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName("body")[0].childNodes[0].nodeValue;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote><p>JavaScript Object Notation</p><p>类似xml，基于文本的交换格式</p><p>更快，更小，更易解析</p></blockquote><p>主要特点：——与javascript的对象表达方式相似</p><p>json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"book"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>:<span class="string">"01"</span>,</span><br><span class="line">            <span class="attr">"language"</span>: <span class="string">"Java"</span>,</span><br><span class="line">            <span class="attr">"edition"</span>: <span class="string">"third"</span>,</span><br><span class="line">            <span class="attr">"author"</span>: <span class="string">"Herbert Schildt"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>:<span class="string">"07"</span>,</span><br><span class="line">            <span class="attr">"language"</span>: <span class="string">"C++"</span>,</span><br><span class="line">            <span class="attr">"edition"</span>: <span class="string">"second"</span>,</span><br><span class="line">            <span class="attr">"author"</span>: <span class="string">"E.Balagurusamy"</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javascript：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span> &gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> object1 = &#123; <span class="string">"language"</span> : <span class="string">"Java"</span>, <span class="string">"author"</span>  : <span class="string">"herbert schildt"</span> &#125;;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;JSON with JavaScript example&lt;/h1&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;Language = "</span> + object1.language+<span class="string">"&lt;/h3&gt;"</span>);  </span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;Author = "</span> + object1.author+<span class="string">"&lt;/h3&gt;"</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> object2 = &#123; <span class="string">"language"</span> : <span class="string">"C++"</span>, <span class="string">"author"</span>  : <span class="string">"E-Balagurusamy"</span> &#125;;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;Language = "</span> + object2.language+<span class="string">"&lt;/h3&gt;"</span>);  </span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;Author = "</span> + object2.author+<span class="string">"&lt;/h3&gt;"</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;hr /&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(object2.language + <span class="string">" programming language can be studied "</span> +</span><br><span class="line">    <span class="string">"from book written by "</span> + object2.author);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;hr /&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="json-简介"><a href="#json-简介" class="headerlink" title="json 简介"></a>json 简介</h3><p>联系xml理解</p><p>相同：——也适用于数据传输的格式</p><ol><li>纯文本</li><li>层级结构</li><li>可通过javascript进行解析</li><li>使用Ajax进行传输</li></ol><p>不同：</p><ol><li>没有标签</li><li>更快</li><li>使用数组</li></ol><hr><h3 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h3><blockquote><p>一种javascript的语法</p></blockquote><ol><li>数值用名/值对表示，中间用“：”隔开，相互之间用“，”隔开</li><li>使用大括号表示一个对象</li><li>使用“【 XXXX】”表示对象</li></ol><p>实例参考json开始</p><hr><h3 id="json的使用"><a href="#json的使用" class="headerlink" title="json的使用"></a>json的使用</h3><p>场景：<br></p><p>前后台的数据传输：后台将数据封装成json格式，前台将它转换成javascript对象，在网页上显示出来</p><p>从web服务器中读取json，作为文件或者httpRequest，前端javaScript中要想得到具体数据，使用<strong>eval（）</strong>来处理，得到一个对象</p><p>但是必须加上一对括号，才能变成javascript的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;从 <span class="built_in">JSON</span> 字符串中创建对象&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;</span></span><br><span class="line"><span class="regexp">名: &lt;span id="fname"&gt;&lt;/</span>span&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span> </span></span><br><span class="line">姓: &lt;span id="lname"&gt;&lt;/span&gt;&lt;br&gt; </span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var txt = '&#123;"employees":[' +</span><br><span class="line">'&#123;"firstName":"John","lastName":"Doe" &#125;,' +</span><br><span class="line">'&#123;"firstName":"Anna","lastName":"Smith" &#125;,' +</span><br><span class="line">'&#123;"firstName":"Peter","lastName":"Jones" &#125;]&#125;';</span><br><span class="line"></span><br><span class="line">var obj = eval ("(" + txt + ")");</span><br><span class="line"></span><br><span class="line">document.getElementById("fname").innerHTML=obj.employees[1].firstName </span><br><span class="line">document.getElementById("lname").innerHTML=obj.employees[1].lastName </span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>解析器：<br></p><p>eval()函数可以执行所有的javascript程序，存在一定的安全隐患，因此一般都是用JSON解析器，将json格式的文件解析</p><p>使用方法：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="built_in">JSON</span>.parse(txt);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"fname"</span>).innerHTML=obj.employees[<span class="number">1</span>].firstName </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"lname"</span>).innerHTML=obj.employees[<span class="number">1</span>].lastName</span><br></pre></td></tr></table></figure><p>使用实例：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSONP 实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://apps.bdimg.com/libs/jquery/1.8.3/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"divCustomers"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$.getJSON(<span class="string">"/try/ajax/jsonp.php?jsoncallback=?"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> html = <span class="string">'&lt;ul&gt;'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++)     &#123;       html += <span class="string">'&lt;li&gt;'</span> + data[i] + <span class="string">'&lt;/li&gt;'</span>;</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="javascript"> html += <span class="string">'&lt;/ul&gt;'</span>;</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">  $(<span class="string">'#divCustomers'</span>).html(html); </span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="JSON-的数据类型和对象"><a href="#JSON-的数据类型和对象" class="headerlink" title="JSON 的数据类型和对象"></a>JSON 的数据类型和对象</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>常见的几种：<br></p><p><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5c987pg3vj30oe09ogly.jpg" alt></p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>必须用大括号包含起来</p><p>具体数据用键值对表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JSONObj = &#123; <span class="string">"name"</span> : <span class="string">"tutorialspoint.com"</span>, <span class="string">"year"</span>  : <span class="number">2005</span> &#125;;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;JSON with JavaScript example&lt;/h1&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;Website Name="</span>+JSONObj.name+<span class="string">"&lt;/h3&gt;"</span>);  </span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;Year="</span>+JSONObj.year+<span class="string">"&lt;/h3&gt;"</span>);</span><br></pre></td></tr></table></figure><p><strong>访问对象的值</strong>：</p><p>用object.key来获取</p><p>使用数组方式获取</p><p>用for-in 来循环对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObj, x;</span><br><span class="line">myObj = &#123; &quot;name&quot;:&quot;w3cschool&quot;, &quot;alexa&quot;:8000, &quot;site&quot;:null &#125;;</span><br><span class="line">//第一种</span><br><span class="line">x = myObj.name;</span><br><span class="line">//第二种</span><br><span class="line">x = myObj[&quot;name&quot;];</span><br><span class="line">//遍历获得</span><br><span class="line">for (x in myObj) &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML += x + &quot;</span><br><span class="line">&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="JSON-与XML格式的比较"><a href="#JSON-与XML格式的比较" class="headerlink" title="JSON 与XML格式的比较"></a>JSON 与XML格式的比较</h3><blockquote><p>XML : 扩展标记语言</p><p>JSON：javascript格式</p></blockquote><p>json：压缩，更快，更小，更易理解</p><p>xml更加的结构化</p><p>JSON</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"company"</span>: Volkswagen,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Vento"</span>,</span><br><span class="line">    <span class="string">"price"</span>: <span class="number">800000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">car</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">company</span>&gt;</span>Volkswagen<span class="tag">&lt;/<span class="name">company</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>Vento<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">price</span>&gt;</span>800000<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">car</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="对象与JSON的相互转换"><a href="#对象与JSON的相互转换" class="headerlink" title="对象与JSON的相互转换"></a>对象与JSON的相互转换</h3><h4 id="对象转换成JSON"><a href="#对象转换成JSON" class="headerlink" title="对象转换成JSON"></a>对象转换成JSON</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//需要下载http://www.json.org/json.js </span><br><span class="line">object.toJSONString()</span><br></pre></td></tr></table></figure><h4 id="JSON转换成Object对象"><a href="#JSON转换成Object对象" class="headerlink" title="JSON转换成Object对象"></a>JSON转换成Object对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用eval（）函数</span><br><span class="line">var obj = eval(&apos;(&apos; + str + &apos;)&apos;); </span><br><span class="line">//使用parseJSON</span><br><span class="line">var obj = str.parseJSON();</span><br></pre></td></tr></table></figure><hr><p>参考：<br></p><blockquote><p><a href="https://www.w3cschool.cn/json/7ta41iht.html" target="_blank" rel="noopener">https://www.w3cschool.cn/json/7ta41iht.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;xml格式的详解&lt;/p&gt;
&lt;p&gt;json格式的详解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://www.arkxkz.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://www.arkxkz.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>正向代理与反向代理</title>
    <link href="https://www.arkxkz.com/2019/07/25/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://www.arkxkz.com/2019/07/25/正向代理与反向代理/</id>
    <published>2019-07-25T03:12:22.000Z</published>
    <updated>2019-07-25T05:28:04.414Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正向代理与反向代理的基本概念</p></blockquote><a id="more"></a><hr><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>代理客户端，用一个服务器作为客户端的client，客户端所发送的所有请求，都由这个代理进行发送，代理人将所得到的的结果发回给客户端。</p><p>实例：<br></p><p>我们经常访问外网，但是由于国内的限制，我们不能够对外部网络进行访问，如google。因此，我们要找个可以进行访问Google网站的服务器帮我们完成这项工作。我们不必知道我们要访问Google的具体地址，我们只需要将这次工作传送给代理服务器，代理服务器它是具备访问外网的服务器，它知道Google的具体地址，它将我们客户机传递给的工作（访问Google），提交，得到的结果传给我们客户，因此，我们就能够访问Google了。<br></p><p>图形展示：<br></p><p><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5bx91j8q6j30m50den0h.jpg" alt></p><p>常用：<strong>Apache</strong></p><hr><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>代理服务器端，代理多台服务器，客户端访问服务器时候，访问的是代理服务器。代理服务器知道你要访问的资源到底放在具体的哪个服务器中。<br></p><p>我们在访问服务器时候，可能该服务器被多个客户端同时访问，如果只有一个服务器提供服务，不能满足正常的功能，因此，分布式部署就被发明了出来，使用多个服务器来分担大流量的访问压力。<br></p><p><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5c0pyie6kj30ma0bfgrj.jpg" alt></p><p>好处：<br></p><ol><li>安全性提高</li><li>负载均衡</li></ol><p>常用：<strong>nginx</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正向代理与反向代理的基本概念&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://www.arkxkz.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://www.arkxkz.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LPA算法和实现</title>
    <link href="https://www.arkxkz.com/2019/07/24/LPA%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.arkxkz.com/2019/07/24/LPA算法和实现/</id>
    <published>2019-07-24T07:52:33.000Z</published>
    <updated>2019-07-24T07:53:46.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Label Propagation 算法 的解析</p><p>LPA算法在mapreduce中划分人物社区的应用</p></blockquote><a id="more"></a><hr><h2 id="Label-Propagation-算法"><a href="#Label-Propagation-算法" class="headerlink" title="Label Propagation 算法"></a>Label Propagation 算法</h2><blockquote><p>基于标签传播的局部社区划分算法</p><p>半监督学习算法</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>社区：<br></p><p>​    一些节点的集合，这些在同一个社区的节点联系较为紧密，在社区之间的节点联系更为疏松。</p><p>​    如图：<br></p><p><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5axtkawalj30eb0h20xf.jpg" alt></p><p><strong>LPA</strong>概念<br></p><p>​    最开始初始化时候，每个节点都有一个自己的标签；开始迭代，当前节点会根据它的相连节点的标签情况来更新自己的节点；迭代多次之后，会有多个节点贴上了相同的标签，形成一个社区。</p><h3 id="LPA原理"><a href="#LPA原理" class="headerlink" title="LPA原理"></a>LPA原理</h3><blockquote><p>假设节点 X，它的相连节点是X1,X2,X3,X4…….，对于每个节点最初初始化标签，标签代表自己所属的社区，节点X根据自己的邻居节点的标签情况（最简单的是标签的数量），来更新自己的标签。</p></blockquote><p>过程图解：<br></p><p><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5ay5kccn9j30lx04fgmj.jpg" alt></p><p>过程不断的持续下去之后，所有可能聚集在一起的节点（相互影响力足够）被划分到了相同的社区（标签相同）</p><p><strong>标签更新</strong></p><ol><li>同步更新</li><li>异步更新</li></ol><p>同步更新：<br></p><p>​    对于第N次迭代中，对于X节点的标签，取决于（N-1）次的所有邻居节点的标签。</p><p>​    数学表达式：<br></p><p>​                <img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5ayfs7u0ij30ei01rglo.jpg" alt></p><p>异步更新<br></p><p>​    对于第N次更新，对于X 节点的标签，取决于第 N 次已经更新完的节点的标签，和 第N次还未更新节点的第（N-1）次迭代结束的标签</p><p>​    数学表达式：<br></p><p>​        <img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5aygo6am8j30iu01xdg2.jpg" alt></p><p><strong>两种标签传播的区别</strong></p><p>同步更新存在震荡问题，当对于一个近似二份网络的时候，标签会对这两个社区来回交换，达不到最终的平衡状态</p><p>图片展示：<br></p><p><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5aykkzvsrj30iv05476u.jpg" alt></p><h3 id="迭代终止条件"><a href="#迭代终止条件" class="headerlink" title="迭代终止条件"></a>迭代终止条件</h3><p>最理想状况：网络中的所有节点的标签不再改变，此时达到一个健壮的社区——社区内的节点不再变化。</p><p>实际问题： 当某个节点的邻居节点的标签情况分布有多个相同的最大社区标签情况，过程会一直执行下去</p><p><strong><em>解决方法</em></strong></p><p>终止条件：对于每一个节点，它的标签是在它邻居中，标签值最大的</p><p>公式表达：<br></p><p><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5ayss6u79j30de03zglh.jpg" alt></p><hr><h2 id="LPA-在mapreduce中的实现"><a href="#LPA-在mapreduce中的实现" class="headerlink" title="LPA 在mapreduce中的实现"></a>LPA 在mapreduce中的实现</h2><h3 id="初始化标签"><a href="#初始化标签" class="headerlink" title="初始化标签"></a>初始化标签</h3><blockquote><p>赋予每个节点一个初始化的标签</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xkz.examples.LPA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LPA 算法的初始化标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LPAInitMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> lableNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">        String[] strAll = value.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">        String name = strAll[<span class="number">0</span>];</span><br><span class="line">        String[] strValue = strAll[<span class="number">1</span>].split(<span class="string">"#"</span>);</span><br><span class="line">        String PRValue = strValue[<span class="number">0</span>];</span><br><span class="line">        String list = strValue[<span class="number">1</span>];</span><br><span class="line">        lableNum++;</span><br><span class="line">        String valueOut = lableNum + <span class="string">"#"</span> + list;</span><br><span class="line">        context.write(<span class="keyword">new</span> Text(name + <span class="string">"#"</span> + PRValue),<span class="keyword">new</span> Text(valueOut));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xkz.examples.LPA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LPAIterMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text value,Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//切分成分</span></span><br><span class="line">        String[] strAll = value.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">        String strHead = strAll[<span class="number">0</span>];</span><br><span class="line">        String strBody = strAll[<span class="number">1</span>];</span><br><span class="line">        String name = strHead.split(<span class="string">"#"</span>)[<span class="number">0</span>];</span><br><span class="line">        String PRValue = strHead.split(<span class="string">"#"</span>)[<span class="number">1</span>];</span><br><span class="line">        String lable = strBody.split(<span class="string">"#"</span>)[<span class="number">0</span>];</span><br><span class="line">        String outList = strBody.split(<span class="string">"#"</span>)[<span class="number">1</span>];</span><br><span class="line">        String[] nameLists = outList.split(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String strTmp: nameLists)&#123;</span><br><span class="line">            String[] element = strTmp.split(<span class="string">":"</span>);</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(element[<span class="number">0</span>]),<span class="keyword">new</span> Text(lable + <span class="string">"#"</span> + name));</span><br><span class="line">        &#125;</span><br><span class="line">        outList = <span class="string">"#"</span> + outList;</span><br><span class="line">        context.write(<span class="keyword">new</span> Text(name),<span class="keyword">new</span> Text(outList));</span><br><span class="line">        context.write(<span class="keyword">new</span> Text(name),<span class="keyword">new</span> Text(<span class="string">"$"</span> + lable));</span><br><span class="line">        context.write(<span class="keyword">new</span> Text(name),<span class="keyword">new</span> Text(<span class="string">"@"</span> + PRValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xkz.examples.LPA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行统计和更改标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LPAIterReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//存储名字与lable的对应关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,String&gt; name_lable = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Double changeCount = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Double changeRate = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer lableCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key,Iterable&lt;Text&gt; value,Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//接收map函数产生的四类K——V对</span></span><br><span class="line">        lableCount ++;</span><br><span class="line"></span><br><span class="line">        String list = <span class="keyword">null</span> , preLable = <span class="keyword">null</span> ,keyPR =<span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; lableLists  = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Text element: value)&#123;</span><br><span class="line">            String strElement = element.toString();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(strElement.charAt(<span class="number">0</span>) == <span class="string">'#'</span> &amp;&amp; strElement.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                list = <span class="keyword">new</span> String(strElement);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(strElement.charAt(<span class="number">0</span>) == <span class="string">'$'</span>&amp;&amp; strElement.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                preLable = strElement.replace(<span class="string">"$"</span>,<span class="string">""</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(strElement.charAt(<span class="number">0</span>) == <span class="string">'@'</span> &amp;&amp; strElement.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                keyPR = strElement.replace(<span class="string">"@"</span> , <span class="string">""</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(strElement.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                lableLists.add(strElement);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String subList = list.replace(<span class="string">"#"</span>,<span class="string">""</span>);</span><br><span class="line">            String[] strSplits = subList.split(<span class="string">";"</span>);</span><br><span class="line">            <span class="comment">//wMap 是受到当前节点——key，影响的节点集合</span></span><br><span class="line">            HashMap&lt;String,Double&gt; wMap = <span class="keyword">new</span> HashMap&lt;String, Double&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String strTmp: strSplits)&#123;</span><br><span class="line">                String[] strElements = strTmp.split(<span class="string">":"</span>);</span><br><span class="line">                wMap.put(strElements[<span class="number">0</span>],Double.valueOf(strElements[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//lableMap是影响当前节点的 标签 和 关联度 （入边权值）的一个map</span></span><br><span class="line">            HashMap&lt;String,Double&gt; lableMap = <span class="keyword">new</span> HashMap&lt;String, Double&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String strTmp: lableLists)&#123;</span><br><span class="line">                String[] strElements = strTmp.split(<span class="string">"#"</span>);</span><br><span class="line">                String lable = strElements[<span class="number">0</span>],name = strElements[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//实现异步更新</span></span><br><span class="line">                <span class="keyword">if</span>(name_lable.containsKey(name))&#123;</span><br><span class="line">                    lable = name_lable.get(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//感觉这一步有点多余，因为不可能出现单方面的影响</span></span><br><span class="line">                <span class="keyword">if</span>( !wMap.containsKey(name))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Double weight = wMap.get(name);</span><br><span class="line">                <span class="comment">//受到当前节点影响，更新lable的权值</span></span><br><span class="line">                <span class="keyword">if</span>(!lableMap.containsKey(lable))&#123;</span><br><span class="line">                    lableMap.put(lable,weight);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    lableMap.put(lable,lableMap.get(lable) + weight);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;String&gt; maxList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            Double maxWeight = <span class="number">0.0</span>;</span><br><span class="line">            <span class="comment">//这种适合数量大的遍历</span></span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String,Double&gt; entry : lableMap.entrySet())&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue() &gt; maxWeight)&#123;</span><br><span class="line">                    maxList.clear();</span><br><span class="line">                    maxList.add(entry.getKey());</span><br><span class="line">                    maxWeight = entry.getValue();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(entry.getValue() == maxWeight)&#123;</span><br><span class="line">                    maxList.add(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//得到最大权值的lable</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(maxList.size());</span><br><span class="line">            String newLable = maxList.get(index);</span><br><span class="line">            <span class="keyword">if</span>(!newLable.equals(preLable))&#123;</span><br><span class="line">                changeCount ++;</span><br><span class="line">            &#125;</span><br><span class="line">            String outList = maxList.get(index) + list;</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(key.toString() + <span class="string">"#"</span> + keyPR),<span class="keyword">new</span> Text(outList));</span><br><span class="line">            <span class="comment">//为了实现异步更新</span></span><br><span class="line">            name_lable.put(key.toString(),newLable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        name_lable.clear();</span><br><span class="line">        changeRate = changeCount / lableCount;</span><br><span class="line">        System.out.print(<span class="string">"-----------------------the changeRate"</span>+ changeRate +<span class="string">"-----------------------"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>注：代码属于做项目的一部分，想要详细代码和解析的可以到我的github上下载，过段时间应该会发布到github上</p><p>参考：</p><blockquote><p><a href="https://cloud.tencent.com/developer/article/1066376" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1066376</a></p><p><a href="http://www.go60.top/view/89.html" target="_blank" rel="noopener">http://www.go60.top/view/89.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Label Propagation 算法 的解析&lt;/p&gt;
&lt;p&gt;LPA算法在mapreduce中划分人物社区的应用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://www.arkxkz.com/categories/algorithm/"/>
    
    
      <category term="LPA" scheme="https://www.arkxkz.com/tags/LPA/"/>
    
  </entry>
  
  <entry>
    <title>pagerank算法及mapreduce中应用</title>
    <link href="https://www.arkxkz.com/2019/07/23/pagerank%E7%AE%97%E6%B3%95%E5%8F%8Amapreduce%E4%B8%AD%E5%BA%94%E7%94%A8/"/>
    <id>https://www.arkxkz.com/2019/07/23/pagerank算法及mapreduce中应用/</id>
    <published>2019-07-23T15:05:51.000Z</published>
    <updated>2019-07-23T15:06:56.826Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pagerank-算法"><a href="#pagerank-算法" class="headerlink" title="pagerank 算法"></a>pagerank 算法</h3><blockquote><p>pagerank algorithm 基本讲解</p><p>pagerank 在大数据中的引用</p><p>pagerank 在mapreduce中的实现</p></blockquote><a id="more"></a><hr><h2 id="pagerank-算法解析"><a href="#pagerank-算法解析" class="headerlink" title="pagerank 算法解析"></a>pagerank 算法解析</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>网页排名算法，最初由google的产品经理Page(至少是之一)发明。</p><p>每一个网页都有一个pageRank值，根据这个值进行排序。</p></blockquote><br><p>实质：<br></p><p>模拟一个人的浏览过程，随机打开一个网页，在网页上花费几分钟，再从此网页上选择一个URL跳转到其它网页 浏览，这样这个人无所事事的一直进行浏览网页，pagerank值来形容他呆在一个网页上的几率大小</p><h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><blockquote><p>将网页看成一个节点，网页的链接看成一条边</p><p>用矩阵来描述整个网络的链接关系（边权值的集合）</p></blockquote><p>pagerank的大小：<br></p><p>1、想象边的权值为投票的票数</p><p>2、边指向某个节点看为对某个节点进行投票</p><p>3、节点的得到票数之和，就是它的PageRank值</p><p>如图所示：<br></p><p><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5a443ioe4j30d008t758.jpg" alt></p><ol><li>初始pagerank值：PR(A) = 0.1   PR(B) =0.1, PR(C) =0.1, PR(D)=0.1</li><li>投票数：A的三条边分别是1/3，B的两条边是1/2，C的一条边是1/1，D的两条边是1/2</li><li>所有节点都将自己的票数按照权值分配投给其它节点</li></ol><p>矩阵：<br></p><p><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5a4aon81uj309g04njro.jpg" alt></p><p>M的含义：</p><p>i——行号</p><p>j——列号</p><p>M（i，j）代表：j节点投向i节点的票数</p><p>所以一次投票过程描述：<br></p><p><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5a4dsd2igj30cc04aq3f.jpg" alt></p><p>在这种情况下只要多投票几次，一定会收敛</p><p>终止条件的参考：</p><ol><li>权值的差值的平均值在一定范围以内</li><li>得出的权值与上一次的权值没有变化</li><li>通过实现测试，观察最终结果应该迭代多少次停止</li></ol><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><blockquote><p>节点间的构建的网络图可能不符合标准</p><p>存在：终止节点问题，陷阱问题</p></blockquote><p><strong>终止节点问题：</strong></p><p>有些节点可能没有出边</p><p>相当于 悠闲的浏览者在浏览完当前页面时候，找不到下一条链接。导致无法执行下一步。</p><p>*<em>在数学模型中的体现 *</em></p><p>*<em>最终迭代下去，会让最终的结果趋近零向量 *</em></p><p><strong>陷阱问题</strong></p><p>有节点只有跳向自己节点的链接，导致悠闲的浏览者不断的跳向自己，不公平的是自己的重要程度增大</p><p><strong>在数学模型中的体现</strong></p><p>行列式中一行只有一个元素存在值，其它都是零</p><p>最终迭代下去，最后的PR值，只有一个节点是有值的，其它节点的值都是零</p><p><strong>解决方案</strong></p><p><strong>V‘ = aM V +（1- a）e</strong></p><p>原理：</p><p>当这个浏览者陷入了麻烦，他不会傻到就在当前页面停留下来或者一直反复浏览自己当前的页面。或者理解为自己会找到方式将自己手中的票投给其它人，而不是留给自己</p><p>他会有一定几率跳向其它更目前页面完全没有关系的页面，或者理解为，随便找个人将自己手中的票投给他</p><p>（1 - a）——跳向其它不相关页面的概率</p><p>（e）—— 当前的PR向量</p><hr><h2 id="在mapreduce中的实现"><a href="#在mapreduce中的实现" class="headerlink" title="在mapreduce中的实现"></a>在mapreduce中的实现</h2><h3 id="map阶段"><a href="#map阶段" class="headerlink" title="map阶段"></a>map阶段</h3><blockquote><p>从输入端得到的关系，细分为片</p><p>计算出矩阵M 中，单个元素与PR向量中一个元素的乘积</p><p>按照K ——V 对的关系传递给reducer</p></blockquote><p>以人物关系网的构建为例</p><p>输入数据格式：当前节点ID，节点当前的PR值，list（节点指向的ID：边的权值</p><p>分割为：</p><p>​    当前节点ID——PR值</p><p>​    节点指向的ID——PR值乘以边的权值</p><h3 id="reduce阶段"><a href="#reduce阶段" class="headerlink" title="reduce阶段"></a>reduce阶段</h3><blockquote><p>mapreduce框架自动将ID值相等的分片整合到一起提交给reduce函数</p><p>reduce函数将它们相加得到这次迭代后该节点的PR值</p></blockquote><p>输入格式：</p><p>​    节点的ID值，lists（PR值）</p><p>输出：</p><p>​    ID值，lists1+lists2+……..</p><hr><h2 id="样例函数实现"><a href="#样例函数实现" class="headerlink" title="样例函数实现"></a>样例函数实现</h2><blockquote><p>以大数据统计人物的重要程度为例</p></blockquote><p><strong>map函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xkz.examples.PR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pagerank 算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRIterMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text value,Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">        String[] strFirst = value.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">        String nameKey = strFirst[<span class="number">0</span>];</span><br><span class="line">        String[] strSecond = strFirst[<span class="number">1</span>].split(<span class="string">"#"</span>);</span><br><span class="line">        Double num = Double.parseDouble(strSecond[<span class="number">0</span>]);</span><br><span class="line">        String strRelation = strSecond[<span class="number">1</span>];</span><br><span class="line">        String[] nameList = strSecond[<span class="number">1</span>].split(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String strTmp: nameList)&#123;</span><br><span class="line">            String[] strSplit = strTmp.split(<span class="string">":"</span>);</span><br><span class="line">            Double value_num = Double.valueOf(strSplit[<span class="number">1</span>])*num;</span><br><span class="line">            BigDecimal bigDecimal = BigDecimal.valueOf(value_num);</span><br><span class="line">            DecimalFormat decimalFormat = <span class="keyword">new</span> DecimalFormat(<span class="string">"0.000000"</span>);</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(strSplit[<span class="number">0</span>]),<span class="keyword">new</span> Text(decimalFormat.format(bigDecimal)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出关系链</span></span><br><span class="line">        strRelation = <span class="string">"#"</span> + strRelation;</span><br><span class="line">        context.write(<span class="keyword">new</span> Text(nameKey),<span class="keyword">new</span> Text(strRelation));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reduce函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xkz.examples.PR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pagerank 算法对新KV统计</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRIterReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key,Iterable&lt;Text&gt; value,Context context)</span><span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">        Double sum  = <span class="keyword">new</span> Double(<span class="number">0</span>);</span><br><span class="line">        String list = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Text tmp: value)&#123;</span><br><span class="line">            String strTmp = tmp.toString();</span><br><span class="line">            <span class="keyword">if</span>(strTmp.charAt(<span class="number">0</span>) == <span class="string">'#'</span> &amp;&amp; strTmp.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                list  = <span class="keyword">new</span> String(strTmp);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(strTmp.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += Double.valueOf(strTmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        BigDecimal bigDecimal = BigDecimal.valueOf(sum);</span><br><span class="line">        DecimalFormat decimalFormat = <span class="keyword">new</span> DecimalFormat(<span class="string">"0.000000"</span>);</span><br><span class="line">        String strRelation = decimalFormat.format(bigDecimal) + list;</span><br><span class="line">        context.write(key, <span class="keyword">new</span> Text(strRelation));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/fengfenggirl/p/pagerank-introduction.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengfenggirl/p/pagerank-introduction.html</a></p><p><a href="https://juejin.im/post/5ac43ad1f265da238155d6fe" target="_blank" rel="noopener">https://juejin.im/post/5ac43ad1f265da238155d6fe</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;pagerank-算法&quot;&gt;&lt;a href=&quot;#pagerank-算法&quot; class=&quot;headerlink&quot; title=&quot;pagerank 算法&quot;&gt;&lt;/a&gt;pagerank 算法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;pagerank algorithm 基本讲解&lt;/p&gt;
&lt;p&gt;pagerank 在大数据中的引用&lt;/p&gt;
&lt;p&gt;pagerank 在mapreduce中的实现&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://www.arkxkz.com/categories/algorithm/"/>
    
    
      <category term="mapreduce" scheme="https://www.arkxkz.com/tags/mapreduce/"/>
    
      <category term="pagerank" scheme="https://www.arkxkz.com/tags/pagerank/"/>
    
  </entry>
  
  <entry>
    <title>hadoop集群和单机版配置</title>
    <link href="https://www.arkxkz.com/2019/07/16/hadoop%E9%9B%86%E7%BE%A4%E5%92%8C%E5%8D%95%E6%9C%BA%E7%89%88%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.arkxkz.com/2019/07/16/hadoop集群和单机版配置/</id>
    <published>2019-07-16T13:14:53.000Z</published>
    <updated>2019-07-17T07:43:44.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初学hadoop基本集群和单机版的配置"><a href="#初学hadoop基本集群和单机版的配置" class="headerlink" title="初学hadoop基本集群和单机版的配置"></a>初学hadoop基本集群和单机版的配置</h3><blockquote><p>hadoop集群的配置<br>hadoop单机版的配置<br>hadoop的Linux版本下编写mapreduce程序</p></blockquote><a id="more"></a><hr><h2 id="hadoop-集群的配置"><a href="#hadoop-集群的配置" class="headerlink" title="hadoop 集群的配置"></a>hadoop 集群的配置</h2><h3 id="初始必备条件"><a href="#初始必备条件" class="headerlink" title="初始必备条件"></a>初始必备条件</h3><p>1、虚拟机或者服务器（我以虚拟机为例）<br>2、centos7<br>3、安装javaJDK版本至少1.8<br>4、官网下载hadoop压缩包到虚拟机中</p><h3 id="开始配置过程"><a href="#开始配置过程" class="headerlink" title="开始配置过程"></a>开始配置过程</h3><p>开启虚拟机，创建hadoop用户,在root态下进行<br>adduser hadoop<br>设置密码<br>passwd hadoop<br>输入免密<br>在用户目录下进行免密登录设置<br>cd home/hadoop/<br>ssh-keygen -t rsa<br>以上的操作在每一台虚拟机上执行<br>进入master<br>设置hosts<br>查看自己的ip<br>ip addr<br>在所有主机中<br>master IPaddr<br>slave1 IPaddr<br>设置hostname<br>vim etc/sysconfig/network<br>NETWORKING = YES<br>HOSTNAME = MASTER<br>确认生效<br>hostname master<br>确认<br>hostname<br>返回master则正确<br>让永久生效<br>vim etc/hostname<br>将原本的hostname删除<br>写上 master<br>在其余主机上进行类似的操作<br>以上是开胃准备，接下来进入网络等配置<br>1、ip addr ——查看IP地址，注意，在每一台主机上观察，记录下所有的ip<br>2、systemctl stop firewalld.service，关掉防火墙，也是在每一台主机进行<br>3、在master上：<br>cd home/hadoop/<br>cat .ssh/id_rsa.pub  》 home/hadoop/id_master<br>将master上的公钥传输给所有的slaves节点上<br>scp ./id_master hadoop ait SERVER: 用户目录<br>4、进入slaves<br>cat id_master 》 .ssh/authorized_keys<br>cp .ssh/id_rsa.pub ./id_slavesX<br>scp .ssh/id_rsa.pub hadoop 艾特SERVER: 用户不露<br>5、进入master<br>将所有的id_slaveX 合并到一起<br>cat id_slavesX 》 .ssh/authorized_keys<br>6、验证，如果   ssh slave1  等操作都不要输入密码则成功<br>7、开始配置hadoop相关文件<br>在 homehadoop 下解压hadoop文件<br>tar -zxvf hadoop-3.2.0.tar.gz<br>配置workers文件<br><br><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g521dcunk3j30m005uq2v.jpg" alt="1"><br><br></p><p>配置hadoop环境变量<br><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g52ur9nns4j30m806yt93.jpg" alt="2"><br><br></p><p>配置核心zujian<br><br><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g52usue598j30mb0fe75k.jpg" alt="3"><br><br><br><br></p><p>配置文件系统核心组件<br><br><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g52vof3omgj30f00483yg.jpg" alt="4"><br><br></p><p>配置yarn组件<br><br><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g52vpqiv35j30ph0okmz7.jpg" alt="5"><br><br></p><p>配置Mapreduce计算框架 <br><br><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g52vqjknd3j30qg0mktat.jpg" alt="6"><br><br><br>将hadoop的配置复制到slave中<br>scp -r home/hadoop/hadoop-3.2.0 hadoop 艾特SERVER<br><strong>扫尾工作</strong><br>配置环境变量<br>在etc/profile<br>写上环境变量，配置完  要让它生效 ！！！<br><br><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g521psoo3tj30dl03lq30.jpg" alt="7"><br>在home/hadoop/ 目录下创建hadoopdata文件<br>mkdir home/hadoop/hadoopdata<br>进行格式化工作<br>hdfs namenode -format<br>进入目录开启文件系统<br>cd home/hadoop/hadoop-3.2.0/sbin<br>开启<br>start-all.sh<br>关闭<br>stop-all.sh<br>查看端口情况<br>jps<br><strong>jps看不到datanode启动</strong><br>说明你多次格式化，将hadoopdata重建<br>再进行格式化</p><hr><hr><h2 id="hadoop的单机配置"><a href="#hadoop的单机配置" class="headerlink" title="hadoop的单机配置"></a>hadoop的单机配置</h2><p>单机配置就只有一个不同<br>不用配置免密登录<br>在本机创建hadoop用户，并以hadoop身份进行一下操作<br>.ssh-keygen -t rsa<br>cat .ssh/id_rsa.pub 》 .ssh/authorized_keys<br>只需要更改一个文件hdfs-site.xml 文件<br><br><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g521ytdgt2j30me0emt9v" alt="8"></p><hr><hr><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>这样集群配置在虚拟机上显得鸡肋， 可以通过 docker 在一台虚拟机达到多台的效果</p><hr><blockquote><p>参考书籍：hadoop大数据实战权威指南 黄冬军版  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;初学hadoop基本集群和单机版的配置&quot;&gt;&lt;a href=&quot;#初学hadoop基本集群和单机版的配置&quot; class=&quot;headerlink&quot; title=&quot;初学hadoop基本集群和单机版的配置&quot;&gt;&lt;/a&gt;初学hadoop基本集群和单机版的配置&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;hadoop集群的配置&lt;br&gt;hadoop单机版的配置&lt;br&gt;hadoop的Linux版本下编写mapreduce程序&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hadoop" scheme="https://www.arkxkz.com/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="https://www.arkxkz.com/tags/hadoop/"/>
    
      <category term="install" scheme="https://www.arkxkz.com/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>mapreduce基本流程</title>
    <link href="https://www.arkxkz.com/2019/07/15/mapreduce%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.arkxkz.com/2019/07/15/mapreduce基本流程/</id>
    <published>2019-07-15T05:09:18.000Z</published>
    <updated>2019-07-15T07:50:16.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hadoop-中的mapreduce"><a href="#hadoop-中的mapreduce" class="headerlink" title="hadoop 中的mapreduce"></a>hadoop 中的mapreduce</h3><blockquote><p>mapreduce的基本流程<br>编程的基本步骤</p></blockquote><a id="more"></a><hr><h2 id="mapreduce-在hadoop中的role"><a href="#mapreduce-在hadoop中的role" class="headerlink" title="mapreduce 在hadoop中的role"></a>mapreduce 在hadoop中的role</h2><p><strong>字面意思</strong><br>在hadoop下先将任务分解，对每个分解的片进行处理<br>将处理后的结构进行reduce，合并和过滤<br>最后得到结构</p><p>基于hadoop 自己只需要编写map 和reduce 程序  </p><p>map（）任务  </p><p>将提交给map的数据提炼处理<br>如wordcount程序中，将每一行的数据按空格划分<br>输出统一格式的 key , value   </p><p>reduce任务</p><p>将提交的 key , value 组进行合并 </p><hr><h2 id="mapper-的过程"><a href="#mapper-的过程" class="headerlink" title="mapper 的过程"></a>mapper 的过程</h2><pre><code>### split    &gt; 将待处理文件按行读取    &gt; 形成 key , value 键值对 提交给用户写的map（）函数    &gt; split框架自身提供，按照文件的数目和文件的大小不同，可能存在多个split    &gt; key值 是偏移量， value 值是一行TEXT### map    &gt; 用户自己书写的函数    &gt; split每产生一对 key ，value对就调用一次map    &gt; map 实现将split提交的值进行划分，处理，形成标准的 key ，value对    &gt; key值代表一个 String，value值是个数    &gt; 在map过程中可以进行数据的清洗等，过滤掉不需要的数据### collect    &gt; 收集 map产生的 kV对    &gt; 将数据存入一个圆形缓冲序列### spill    &gt; 溢出处理    &gt; 查看 环形缓冲区是否填满，填满 将数据存入到磁盘中（临时产生文件）    &gt; 在写入临时产生文件时候，也要进行排序等步骤### combine    &gt; 对应split产生的所有 KV对    &gt; 将临时文件进行合并    &gt; 合并规则就是将有相同的k值的v相加</code></pre><hr><hr><h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><h3 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h3><pre><code>&gt; 定位——运输工具&gt; 等同于copy&gt; 从mapper 的输出文件里拷贝一片数据&gt; 如果数据大小合适，放在内存，数据过大，放入磁盘中</code></pre><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><pre><code>&gt; 运行两个后台管理线程&gt; 管理内存和磁盘&gt; 保证内存和磁盘的的数量和大小都要合适</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><pre><code>&gt; 主要进行归并排序&gt; 因为在mapper阶段已经进行了内部的合并和排序&gt; 结果是KV对&gt; K——string &gt; V——list</code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><pre><code>&gt; 用户袭击写的reduce（）&gt; 用于数据的合并</code></pre><h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><pre><code>&gt; 将数据写入到hdfs</code></pre><hr><hr><h2 id="mapreduce-程序的基本结构"><a href="#mapreduce-程序的基本结构" class="headerlink" title="mapreduce 程序的基本结构"></a>mapreduce 程序的基本结构</h2><blockquote><p>以 wordcount为例</p></blockquote><h3 id="主程序-WordCount"><a href="#主程序-WordCount" class="headerlink" title="主程序 WordCount"></a>主程序 WordCount</h3><blockquote><p>role —— 是业务逻辑相关的信息</p></blockquote><p>1、那个是mapper<br>2、那个是reducer<br>3、数据在哪里，和reducer层的输出数据类型<br>4、输出结果放在哪里<br>5、向yarn集群提交作业</p><h3 id="map程序"><a href="#map程序" class="headerlink" title="map程序"></a>map程序</h3><blockquote><p>封装在mapper类中，mapper类必须继承Mapp<br>相当于重写map函数</p></blockquote><p>1、拿到split分片的数据<br>2、将数据划分<br>3、（数据清洗）<br>4、生成 KV对 提交给用户写的map（）函数</p><h3 id="reduce程序"><a href="#reduce程序" class="headerlink" title="reduce程序"></a>reduce程序</h3><blockquote><p>reducer将shuffle传输过来的大量 KV组进行合并后，聚集相同的 KV组 提交给reduce<br>框架传递一组就调用一次</p></blockquote><p>1、计数器<br>2、新的 KV对 提交 </p><hr><blockquote><p>参考文章<br><a href="https://blog.csdn.net/qq_38200548/article/details/83050907" target="_blank" rel="noopener">https://blog.csdn.net/qq_38200548/article/details/83050907</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;hadoop-中的mapreduce&quot;&gt;&lt;a href=&quot;#hadoop-中的mapreduce&quot; class=&quot;headerlink&quot; title=&quot;hadoop 中的mapreduce&quot;&gt;&lt;/a&gt;hadoop 中的mapreduce&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;mapreduce的基本流程&lt;br&gt;编程的基本步骤&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hadoop" scheme="https://www.arkxkz.com/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="https://www.arkxkz.com/tags/hadoop/"/>
    
      <category term="mapreduce" scheme="https://www.arkxkz.com/tags/mapreduce/"/>
    
  </entry>
  
  <entry>
    <title>ssh使用详解</title>
    <link href="https://www.arkxkz.com/2019/07/12/ssh%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.arkxkz.com/2019/07/12/ssh使用详解/</id>
    <published>2019-07-12T15:53:20.000Z</published>
    <updated>2019-07-12T16:17:55.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ssh使讲解"><a href="#ssh使讲解" class="headerlink" title="ssh使讲解"></a>ssh使讲解</h3><blockquote><p>ssh 远程连接 的使用<br>ssh 的相关讲解<br>可以结合 hadop分布搭建ssh设置 理解</p></blockquote><a id="more"></a><hr><h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><p><strong>定义</strong><br>        远程连接工具</p><h2 id="基本使用到的指令"><a href="#基本使用到的指令" class="headerlink" title="基本使用到的指令"></a>基本使用到的指令</h2><blockquote><p>ssh hostname      hostname只要在hosts和network文件里配置了与对应IP地址对应<br>                   hostname就可以写名称，不然 必须写ip地址<br>                   默认用户与当前用户一致<br>                   不一致将 hostname 改为 usr@ip<br>                   默认 ssh 的默认端口为22    默认登录用户与当前用户一致<br>ssh -p    port hostname<br>                   作用：<br>                       远程登录hostname主机</p><p>scp path usr@ip:path            远程复制文件</p><p>ssh-keygen    -t rsa                生成用户自己的公钥和私钥</p></blockquote><h2 id="基本讲解"><a href="#基本讲解" class="headerlink" title="基本讲解"></a>基本讲解</h2><p>解决问题</p><pre><code>当需要大量反复远程切换登录时候，免去每次都需要输入密码的过程</code></pre><p><strong>公钥登录</strong></p><p>原理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用户将自己的公钥传输到远程主机中</span><br><span class="line"></span><br><span class="line">登录时候，远程主机向用户发送随机字符串，</span><br><span class="line"></span><br><span class="line">用户用自己的私钥加密</span><br><span class="line"></span><br><span class="line">再发回远程主机</span><br><span class="line"></span><br><span class="line">远程主机用自己的公钥解密，成功，证明可信，就不再需要密码</span><br></pre></td></tr></table></figure><p>每个用户想要享受免密登录 ，就要在自己的目录下创建 .ssh 文件</p><p>id_rsa 是用户的私钥</p><p>id_rsa.pub 是用户的公钥</p><p>authorized_keys 是远程主机储存  用户公钥的地方</p><pre><code>解密时候需要用到其中的公钥</code></pre><hr><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://blog.diqigan.cn/posts/ssh-command-in-linux.html" target="_blank" rel="noopener">https://blog.diqigan.cn/posts/ssh-command-in-linux.html</a></p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ssh使讲解&quot;&gt;&lt;a href=&quot;#ssh使讲解&quot; class=&quot;headerlink&quot; title=&quot;ssh使讲解&quot;&gt;&lt;/a&gt;ssh使讲解&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;ssh 远程连接 的使用&lt;br&gt;ssh 的相关讲解&lt;br&gt;可以结合 hadop分布搭建ssh设置 理解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="order" scheme="https://www.arkxkz.com/categories/order/"/>
    
    
      <category term="linux" scheme="https://www.arkxkz.com/tags/linux/"/>
    
      <category term="ssh" scheme="https://www.arkxkz.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>linux环境变量配置</title>
    <link href="https://www.arkxkz.com/2019/07/12/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.arkxkz.com/2019/07/12/linux环境变量配置/</id>
    <published>2019-07-12T05:54:30.000Z</published>
    <updated>2019-07-12T06:43:36.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在linux中（centos）中配置环境变量"><a href="#在linux中（centos）中配置环境变量" class="headerlink" title="在linux中（centos）中配置环境变量"></a>在linux中（centos）中配置环境变量</h2><blockquote><p>让配置的环境变量一次生效，不用下次登录时启动<br>讲解各个文件的作用</p></blockquote><a id="more"></a><hr><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><pre><code>1. 理解每个与环境变量配置先关文件的意义2. 正确配置环境变量</code></pre><hr><h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><blockquote><p>以 java jdk 配置环境变量为例</p></blockquote><p>以用户（不是以root）身份配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//我的 jdk 放在 /usr/java 下</span><br><span class="line">//假设用户名为 ark</span><br><span class="line">//进入/home/ark/</span><br><span class="line"></span><br><span class="line">cd ~/</span><br><span class="line"></span><br><span class="line">//编辑 .bashrc 文件</span><br><span class="line"></span><br><span class="line">//vim ./.bashrc</span><br></pre></td></tr></table></figure><p>配置变量：<br><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g4x1p0ia92j30nr0f9t9j.jpg" alt></p><p>如果要扩大范围，进入以下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//将用户切换为root</span><br><span class="line"></span><br><span class="line">su root</span><br><span class="line"></span><br><span class="line">//进入全局环境变量配置</span><br><span class="line"></span><br><span class="line">cd /etc</span><br><span class="line"></span><br><span class="line">vim bashrc</span><br></pre></td></tr></table></figure><p>配置变量：</p><p><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g4x1vy1edbj30n302aa9y.jpg" alt></p><hr><hr><h1 id="各类文件地位"><a href="#各类文件地位" class="headerlink" title="各类文件地位"></a>各类文件地位</h1><p>1、~/.bash_profile</p><pre><code>是配置环境变量的文件缺陷：    1. 只启动一次，就是在编辑后  source ~/.bash_profile   之后登陆不会自动启动，需要自己启动    2. 只配置了当前用户， 如果切换用户，任然没有作用解决：    **在~/.bashrc中末尾增加 source ~/.bash_profile**</code></pre><p>2、~/.bashrc</p><pre><code>感觉比较认可的配置文件好处：    1. 每次启动都会自己启动    2. 同时拥有隔离性，不能感触到配置的环境变量解释：    只有此用于（ark）在 /home/ark/ 目录和子目录下能操作配置的环境变量</code></pre><p>3、/etc/.bashrc</p><pre><code>地位： 暴力配置法，一键解决问题一旦在此文件配置，适用于所有用户在所有位置</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在linux中（centos）中配置环境变量&quot;&gt;&lt;a href=&quot;#在linux中（centos）中配置环境变量&quot; class=&quot;headerlink&quot; title=&quot;在linux中（centos）中配置环境变量&quot;&gt;&lt;/a&gt;在linux中（centos）中配置环境变量&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;让配置的环境变量一次生效，不用下次登录时启动&lt;br&gt;讲解各个文件的作用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://www.arkxkz.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>hadoop分布式搭建ssh设置</title>
    <link href="https://www.arkxkz.com/2019/07/11/hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BAssh%E8%AE%BE%E7%BD%AE/"/>
    <id>https://www.arkxkz.com/2019/07/11/hadoop分布式搭建ssh设置/</id>
    <published>2019-07-11T15:33:45.000Z</published>
    <updated>2019-07-11T16:30:38.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="天坑配置ssh"><a href="#天坑配置ssh" class="headerlink" title="天坑配置ssh"></a>天坑配置ssh</h1><blockquote><p>hadoop 部署第一步在服务器或者虚拟机配置网络</p></blockquote><blockquote><p>达到要求能够相互免密登录</p></blockquote><a id="more"></a><hr><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>网络上的教程 和 书中的指导都没能完全的解决问题，</p><p>没有一个完整的配置hadoop 集群 的最开始步骤 ssh 配置</p><p>常见问题：</p><pre><code>1. 可能因为版本不同导致配置方式失效2. 在配置过程中不完全，只实现了master节点可以无密登录slave节点</code></pre><hr><hr><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><ul><li>hadoop-3.2.0 *</li></ul><hr><hr><h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemtcl status firewalld.service //查看防火墙状态</span><br><span class="line"></span><br><span class="line">systemtcl stop firewalld.service   //关闭防火墙</span><br><span class="line"></span><br><span class="line">systemtcl disable firewalld.service //永远关闭防火墙</span><br></pre></td></tr></table></figure><h2 id="免密钥登录配置"><a href="#免密钥登录配置" class="headerlink" title="免密钥登录配置"></a>免密钥登录配置</h2><p>目的：为了在启动分布式的hdfs时候master节点能直接控制所有slave节点</p><h3 id="master主机的配置"><a href="#master主机的配置" class="headerlink" title="master主机的配置"></a>master主机的配置</h3><p>切换用户为hadoop用户（不要为root）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//在 ~ 目录下 ，生成密钥，自动产生.ssh目录</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">//将需要的公钥导入</span><br><span class="line"></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">//执行同样的骚操作在slaves上</span><br><span class="line"></span><br><span class="line">//将slaves上的公钥复制到master节点</span><br><span class="line"></span><br><span class="line">scp ~/.ssh/id_rsa.pub 用户名@master:~/id_rsa_n.pub </span><br><span class="line"></span><br><span class="line">//在master中导入这些公钥</span><br><span class="line"></span><br><span class="line">cat ~/id_rsa_n &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">//将这些公钥发送到slaves节点中</span><br><span class="line"></span><br><span class="line">scp ~/.ssh/authorized_keys 用户@slaves:~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//关键一步来了</span><br><span class="line">//一定要将所有的authorized_keys 权限设置为600</span><br><span class="line"></span><br><span class="line">chomod 600 ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">//验证</span><br><span class="line"></span><br><span class="line">ssh 主机名</span><br><span class="line"></span><br><span class="line">//如果不需要输入密码则成功</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;天坑配置ssh&quot;&gt;&lt;a href=&quot;#天坑配置ssh&quot; class=&quot;headerlink&quot; title=&quot;天坑配置ssh&quot;&gt;&lt;/a&gt;天坑配置ssh&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;hadoop 部署第一步在服务器或者虚拟机配置网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;达到要求能够相互免密登录&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="hadoop ssh" scheme="https://www.arkxkz.com/tags/hadoop-ssh/"/>
    
  </entry>
  
</feed>
